#!/bin/bash

!<<NS_COMMENT
Name            : nsu_unarchive_trun 
Purpose         : To unarchive test which are archived & load database 
Usage           : nsu_unarchive_trun -s <TR> -e <TR> | -n <TR> -p <Partition>
Initial Version : Thursday, July 29 2010
NS_COMMENT

# Contains Utility functions
. $NS_WDIR/bin/nsi_repo_lib

chk_disk_free() 
{
  REQ_SIZE=`du -bs $ARCHIVE | awk '{print $1}'`  #Tar file size in bytes
  REQ_SIZE=`expr $REQ_SIZE \* 20 / 1024`  #Required size = 20 * tar size in KB

  #DF_AVAIL=`df | awk '{if($NF == "/") print $(NF-2)}'`
  DF_AVAIL=`df -T $NS_WDIR | tail -1 | awk '{print $5}'` #Available disk in KB

  if [ "X$DF_AVAIL" = "X" ]; then
    echo "Could not get free disk space"
    echo "Unable to unarchive Partition '$PARTITION'"
    exit 1
  elif [ $DF_AVAIL -le $REQ_SIZE ]; then
    echo "Free disk space $DF_AVAIL KB is less than $REQ_SIZE KB"
    echo "Unable to unarchive Partition '$PARTITION'"
    exit 1
  fi
}


ISND=0

remove_csv_offset_file()
{
  if [ "X$IS_PARTITION_TEST" = "X1" ]; then
    ALL_PARTITION=`ls $NS_WDIR/logs/TR$TR/ | grep "^[0-9]*$"`
    for PARTITION_NAME in $ALL_PARTITION
    do
      #remove ns csv offset files
      rm $NS_WDIR/logs/TR${TR}/${PARTITION_NAME}/reports/csv/.*.csv.offset 2>/dev/null
      #remove nd csv offset files
      if [ "X$ISND" = "X1" ]; then
        rm $NS_WDIR/logs/TR${TR}/${PARTITION_NAME}/nd/csv/*/.*.csv.offset 2>/dev/null
        rm $NS_WDIR/logs/TR${TR}/${PARTITION_NAME}/nd/csv/.*.csv.offset 2>/dev/null
      fi
    done
    rm $NS_WDIR/logs/TR${TR}/common_files/reports/csv/.*.csv.offset 2>/dev/null
    if [ "X$ISND" = "X1" ]; then
      rm $NS_WDIR/logs/TR${TR}/nd/csv/*/.*.csv.offset 2>/dev/null
      rm $NS_WDIR/logs/TR${TR}/nd/csv/.*.csv.offset 2>/dev/null
    fi
  else
    rm $NS_WDIR/logs/TR${TR}/reports/csv/.*.csv.offset 2>/dev/null
    if [ "X$ISND" = "X1" ]; then
      rm $NS_WDIR/logs/TR${TR}/nd/csv/*/.*.csv.offset 2>/dev/null
      rm $NS_WDIR/logs/TR${TR}/nd/csv/.*.csv.offset 2>/dev/null
    fi
  fi
}

load_database() {

  if [ -f $NS_WDIR/logs/TR$TR/sorted_scenario.conf ];then
    ISND=`grep ^NET_DIAGNOSTICS_SERVER $NS_WDIR/logs/TR$TR/sorted_scenario.conf | cut -d ' ' -f2`
  else
    ISND=`grep ^NET_DIAGNOSTICS_SERVER $NS_WDIR/logs/TR$TR/scenario | cut -d' ' -f2`
  fi
  if [ "X$ISND" == "X" -o "X$ISND" == "X0" ];then
    ISND=0
  else
    ISND=1
  fi
#if [ \( $IS_PARTITION_TEST == 1 \) -o \( $P_FLAG == 1 \) ];then
 #ls $TRUN/common_files/reports/csv/*.csv  >/dev/null 2>&1 
 #if [ $? == 0 ];then
    echo "	Loading database for $STRING '$CUR_TR'"
    #i found that nsu_import works only if u are in NS_WDIR
    cd $NS_WDIR

    if [ $P_FLAG == 1 ];then #if partition
      $NS_WDIR/bin/neu_ns_db_upload_partition $TR $PARTITION
      if [ $? != 0 ];then
        echo "Error in running command '$NS_WDIR/bin/neu_ns_db_upload_partition $TR $PARTITION'" 
        EXIT_VAL=1
        return
      fi

      if [ $ISND != 0 ];then #if NET_DIGNOSTICS keyword enabled in scenario
        $NS_WDIR/bin/neu_nd_db_upload_partition $TR $PARTITION
        if [ $? != 0 ];then
          echo "Error in running command '$NS_WDIR/bin/neu_nd_db_upload_partition $TR $PARTITION'" 
          EXIT_VAL=1
          return
        fi
      fi
    #fi
    else  #if TR can be with/without partition
      remove_csv_offset_file
      nsu_import $TR >$TRUN/nsu_import.log 2>&1
    fi
#else
# ls $TRUN/reports/csv/*.csv  >/dev/null 2>&1 
# if [ $? == 0 ];then
#    echo "	Loading database for $STRING '$CUR_TR'"
#    #i found that nsu_import works only if u are in NS_WDIR
#    cd $NS_WDIR
#    nsu_import $TR >$TRUN/nsu_import.log 2>&1
# fi
#fi
}

update_summary_top() {

 #Get User:Group
 OWNER=`stat -c %U:%G $TRUN/summary.top`
 #echo "OWNER=$OWNER"
 echo "	Saving/Updating summary.top of $STRING '$CUR_TR'"

 cat $TRUN/summary.top | awk -F'|' '{
              for(i=1; i <NF; i++) {
                if(i == 14) {
                  if(match($i, "AR"))
                    printf "R|";
                  else if(match($i, "AW"))
                    printf "W|";
                } else {
                   printf $i"|";
                }
              }
              print $i
            }' >$TRUN/summary.top.save

 chown $OWNER $TRUN/summary.top.save
 #mv $TRUN/summary.top.save $TRUN/summary.top
}

unarchive_tr_or_partition()
{
  TRUN="$NS_WDIR/logs/TR$CUR_TR"

  if [ $P_FLAG == 1 ];then
    ARCHIVE="$TRUN/archive$PARTITION.tar.gz"
  else
    ARCHIVE="$TRUN/archive$CUR_TR.tar.gz"
  fi

  if [ ! -d $TRUN ];then
    nsi_repo_download -t $CUR_TR 1>/dev/null 2>&1
  fi

  # TR must exist
  if [ ! -d $TRUN ];then
     echo "$STRING '$CUR_TR' does not exist."
     if [ $N_FLAG == 1 ];then
       echo "Unable to unarchive $STRING '$CUR_TR'" 
       EXIT_VAL=1
     fi
     return 
  fi

  # summary.top must exist
  if [ ! -f $TRUN/summary.top ];then
     echo "$STRING '$CUR_TR' does not have summary.top"
     if [ $N_FLAG == 1 ];then
       echo "Unable to unarchive $STRING '$CUR_TR'" 
       EXIT_VAL=1
     fi
     return 
  fi

  # Must not be already archived
  if [ ! -f $ARCHIVE ];then
    echo "$ARCHIVE for $STRING '$CUR_TR' does not exist."
    if [ $N_FLAG == 1 ];then
      echo "Unable to unarchive $STRING '$CUR_TR'" 
      EXIT_VAL=1
    fi
    return 
  fi

  #Check if enough space is available to untar
  chk_disk_free

    #if partition given then do following
    if [ $P_FLAG == 1 ];then
      #prev of current
      PREV_PARTITION=`grep "PreviousPartition" $TRUN/.partition_info.txt`
      PREV_PARTITION_NUMBER=`echo $PREV_PARTITION | cut -d'=' -f 2`

      #next of current
      NEXT_PARTITION=`grep "NextPartition" $TRUN/.partition_info.txt`
      NEXT_PARTITION_NUMBER=`echo $NEXT_PARTITION | cut -d'=' -f 2`
      NEXT_PREV_PARTITION=`grep "PreviousPartition" $NS_WDIR/logs/TR$TR/$NEXT_PARTITION_NUMBER/.partition_info.txt`

      #next of prev
      PREV_NEXT_PARTITION=`grep "NextPartition" $NS_WDIR/logs/TR$TR/$PREV_PARTITION_NUMBER/.partition_info.txt`

      if [ $PREV_PARTITION_NUMBER -ne 0 ];then
        #replace prev partition NextPartition in file .partition_info.txt with current partition
        sed -i "s/$PREV_NEXT_PARTITION/NextPartition=$PARTITION/" $NS_WDIR/logs/TR$TR/$PREV_PARTITION_NUMBER/.partition_info.txt
      fi

      if [ $NEXT_PARTITION_NUMBER -ne 0 ];then
        #replace next partition PrevPartition in file .partition_info.txt with current partition
        sed -i "s/$NEXT_PREV_PARTITION/PreviousPartition=$PARTITION/" $NS_WDIR/logs/TR$TR/$NEXT_PARTITION_NUMBER/.partition_info.txt
      fi

      echo "	Established link successfully between partitions."
  
      #link scripts .. DISCUSS HERE
    fi
 
  echo "Unarchiving $STRING '$CUR_TR'"
 
  update_summary_top
  #untar file
  cd $TRUN
  #echo TRUN=$TRUN
  echo "	Unompressing $STRING '$CUR_TR'"
  tar xzf $ARCHIVE 2>/dev/null
  if [ $? != 0 ];then
     echo "Uncompression of $STRING '$CUR_TR' failed."
     echo "Unable to unarchive $STRING '$CUR_TR'"
     if [ $N_FLAG == 1 ];then
       EXIT_VAL=1
     fi
     rm -f $TRUN/summary.top.save
     return 
  fi

  #After doing untar we have move temp summary.top to original one
  mv $TRUN/summary.top.save $TRUN/summary.top

  nsu_update_trun $TR
 
  #Remove tar only if TR is not uploaded(normal netstorm) on Repo OR Repo is configured(NSRepo client)
  TR_UPLOAD_STATUS=`nsi_repo_get_tr_upload_status $TR`
  REPO_LIB_STATUS=`nsi_repo_get_config`
  if [ $TR_UPLOAD_STATUS == 0 -o "XX$REPO_LIB_STATUS" != "XX" ];then
    rm -f $ARCHIVE
  fi
  
  stat $TRUN/.db_exists 1>/dev/null 2>/dev/null

  if [ $? -eq 0 ]; then
    echo "DB was not removed while archiving partition, hence not uploading again"
    rm -f $TRUN/.db_exists
  else
    load_database
  fi
     
  echo "	$STRING '$CUR_TR' unarchived successfully."
  echo "	Total size of $STRING '$CUR_TR' after unarchive is `du -hs $TRUN | awk '{print $1}'`"
}

#Create archive
create_unarchive() {

  for CUR_TR in `seq $START_TR $END_TR` 
  do
   unarchive_tr_or_partition
  done
}

usage() {
 
 echo "$0 -n <TR number> -p <Partition> | -s <TR number> -e <TR number>"
 echo "Example:"
 echo "$0 -n 1001 -p 20140822101200"
 echo "OR"
 echo "$0 -s 1001 -e 1234"
 exit 1
}

#While archiving/unarchiving same partitions in parallel, race condition may occur
#While archiving/unarchiving different partitions in parallel, we may get wrong value of remaining disk space.

#This function doesn't allow archive or unarchive shells to execute in parallel, even on different controllers.

check_if_prev_shell_running()
{
  PS_OUT=`ps -ef`

  #check if any gui for archive is running
  num_gui_ps=`echo "$PS_OUT" | grep "nsu_archive_trun.tomcat" | grep -v "grep" | wc -l`
  if [ $num_gui_ps -gt 0 ]; then
    echo "Archive process is running on machine, hence Exiting"
    exit 1
  fi

  #check if another gui for unarchive is running
  num_gui_ps=`echo "$PS_OUT" | grep "nsu_unarchive_trun.tomcat" | grep -v "grep" | wc -l`
  if [ $num_gui_ps -gt 1 ]; then
    echo "Another unarchive process is running on machine, hence Exiting"
    exit 1
  fi

  #check if any shell for archive is running
  num_shell_ps=`echo "$PS_OUT" | grep -v "nsu_archive_trun.tomcat" | grep "nsu_archive_trun" | grep -v "grep" | wc -l`
  if [ $num_shell_ps -gt 0 ]; then
    echo "Archive process is running on machine, hence Exiting"
    exit 1
  fi
  
  #check if another shell for unarchive is running
  num_shell_ps=`echo "$PS_OUT" | grep -v "nsu_unarchive_trun.tomcat" | grep "nsu_unarchive_trun" | grep -v "grep" | wc -l`
  if [ $num_shell_ps -gt 1 ]; then
    echo "Another uarchive process is running on machine, hence Exiting"
    exit 1
  fi
}
#######################################

N_FLAG=0
S_FLAG=0
E_FLAG=0
P_FLAG=0

TR=0
START_TR=0
END_TR=0
EXIT_VAL=0
PARTITION=0
STRING="TestRun"

IS_PARTITION_TEST=0

USER=`whoami`
if [ "X$USER" != "Xcavisson" ];then
    echo "You must be logged in as cavisson user to execute this command"
    exit -1
fi

if [ "XX$NS_WDIR" == "XX" ];then
    echo "NS_WDIR is not exported."
    exit 1
fi

check_if_prev_shell_running

while getopts n:s:e:p:? c
do
  case $c in
	n) echo $OPTARG | egrep "[^0-9]" >/dev/null 2>&1
           if [ $? == 0 ];then
              echo "TestRun must be an integer value."
              exit 1
           fi
           START_TR=$OPTARG
	   END_TR=$START_TR
     TR=$START_TR
	   N_FLAG=1;;
	s) echo $OPTARG | egrep "[^0-9]" >/dev/null 2>&1
           if [ $? == 0 ];then
              echo "TestRun must be an integer value."
              exit 1
           fi
	   START_TR=$OPTARG
	   S_FLAG=1;;
	e) echo $OPTARG | egrep "[^0-9]" >/dev/null 2>&1
           if [ $? == 0 ];then
              echo "TestRun must be an integer value."
              exit 1
           fi

           END_TR=$OPTARG
	   E_FLAG=1;;
  p) echo $OPTARG | egrep "[^0-9]" >/dev/null 2>&1
           if [ $? == 0 ];then
              echo "Partition must be an integer value."
              exit 1
           fi
     PARTITION=$OPTARG
     P_FLAG=1;;
	?) usage ;;
  esac
done

#partition option cannot be used with range
if [ \( $P_FLAG == 1 \) -a \( $S_FLAG == 1 -o $E_FLAG == 1 \) ];then
  echo "Partition cannot be used with start and end option" 
  exit 1
fi

if [ $P_FLAG == 1 ];then
  START_TR=$START_TR/$PARTITION
  END_TR=$END_TR/$PARTITION
  STRING="Partition"
fi

if [ -f $NS_WDIR/logs/TR$START_TR/.curPartition ]; then
  IS_PARTITION_TEST=1
fi

if [ \( $N_FLAG == 1 -a $S_FLAG == 0 -a $E_FLAG == 0 \) -o \( $N_FLAG == 0 -a $S_FLAG == 1 -a $E_FLAG == 1 \) -o \( $P_FLAG == 1 \) ];then
    #if not partition then only execute below check
    if [ $P_FLAG == 0 ];then
      if [ $START_TR -gt $END_TR ];then
        echo "Start TestRun '$START_TR' must be smaller than End TestRun '$END_TR'" 
        exit 1
      fi
    fi

   if [ $P_FLAG -eq 1 ]; then
     nsu_unarchive_partition -t $TR -p $PARTITION  #unarchive single partition
   elif [ $IS_PARTITION_TEST -eq 1 ];then
     CUR_TR=$START_TR
     unarchive_tr_or_partition #call one time
   else
     create_unarchive #call in loop
   fi
else
   usage
fi

exit $EXIT_VAL
