#!/bin/bash
# shell make tar of current existing file in TRXXXX/partition in same  TRXXXX directory.
# You pass lower & upper tests, it will make tar of each tests including both tests.
#
#By Rajendra Prasad
#
#By Maninder Singh 22/03/2016

# Including utility functions
. $NS_WDIR/bin/nsi_repo_lib

chk_disk_free()
{
  #DF_AVAIL=`df | awk '{if($NF == "/") print $(NF-2)}'`
  DF_AVAIL=`df -T $NS_WDIR | tail -1 | awk '{print $5}'`
  REQ_SIZE=`du -bs $TR_PATH/$PARTITION | awk '{print $1}'`
  REQ_SIZE=`expr $REQ_SIZE / 1024`  #Converting to KB

  if [ "X$DF_AVAIL" = "X" ]; then
    echo "Unable to get available disk space"
    echo "Unable to archive test run '$TR/$PARTITION'"
    exit 1
  elif [ $DF_AVAIL -le $REQ_SIZE ]; then
    echo "Free disk space $DF_AVAIL KB is less than TR size of $REQ_SIZE KB"
    echo "Unable to archive test run '$TR/$PARTITION'"
    exit 1
  fi
}

update_summary_top()
{
  echo "Saving/Updating summary.top ..."

  #Get User:Group
  OWNER=`stat -c %U:%G $NS_WDIR/logs/TR$TR/summary.top`
 
  cat $NS_WDIR/logs/TR$TR/summary.top | awk -F'|' '{
               for(i=1; i <NF; i++) {
                 if(i == 14) printf "A";
                 printf $i"|";
               }
               print $i
             }' >$TR_PATH/$PARTITION/.summary.top
 
  chown $OWNER $TR_PATH/$PARTITION/.summary.top
}

remove_database()
{
  if [ "X$REMOVE_DB" = "X0" ]; then
    echo "DB will not be removed ..."
    touch $TR_PATH/$PARTITION/.db_exists
    return
  fi

  if [ $P_FLAG == 1 ]; then  #if partition 
    ARGS="-t $TR -p $PARTITION -d"
  else
    ARGS="-t $TR -d"
  fi

  echo "Dropping NS database tables ..."
  $NS_WDIR/bin/db_tbl_mgr $ARGS -m "NS"
  if [ $? != 0 ];then
    echo "Error in running command '$NS_WDIR/bin/db_tbl_mgr $ARGS -m \"NS\"'" 
  else
    echo "NS Database tables dropped successfully ..."
  fi

  if [ $ISND -ne 1 ]; then #if NET_DIGNOSTICS keyword enabled in scenario
    return
  fi

  echo "Dropping ND database tables ..."
  $NS_WDIR/bin/db_tbl_mgr $ARGS -m "ND"
  if [ $? != 0 ];then
    echo "Error in running command '$NS_WDIR/bin/db_tbl_mgr $ARGS -m \"ND\"'" 
  else
    echo "ND Database tables dropped successfully ..."
  fi
}

update_partition_links()
{
  ERROR_FLAG=1		#Setting this flag initially to 1 and set it to 0 after successful completion 
  #Find prev partition of current partition
  PREV_PARTITION=`grep "PreviousPartition" $TR_PATH/$PARTITION/.partition_info.txt | awk -F'=' '{print $2}'`
  if [ "X$PREV_PARTITION" == "X" ]; then
    echo "Previous partition not found in file '$TR_PATH/$PARTITION/.partition_info.txt'" 
    return 
  fi

  #next of current
  NEXT_PARTITION=`grep "NextPartition" $TR_PATH/$PARTITION/.partition_info.txt | awk -F'=' '{print $2}'`
  if [ "X$NEXT_PARTITION" = "X" ]; then
    echo "Next partition not found in file '$TR_PATH/$PARTITION/.partition_info.txt'" 
    return 
  fi

  if [ $NEXT_PARTITION -eq 0 -a $PREV_PARTITION -eq 0 ];then
    echo "There is only one partition its better to archive whole TR"
    return
  fi
  
  if [ $NEXT_PARTITION -ne 0 ]; then
    sed -i "s/^PreviousPartition=.*/PreviousPartition=$PREV_PARTITION/" $TR_PATH/$NEXT_PARTITION/.partition_info.txt
  fi

  if [ $PREV_PARTITION -ne 0 ]; then
    sed -i "s/^NextPartition=.*/NextPartition=$NEXT_PARTITION/" $TR_PATH/$PREV_PARTITION/.partition_info.txt
  fi

  echo "Established link successfully between partitions ..."
  ERROR_FLAG=0		#Links created successfully so resetting error flag
}

make_tar()
{

  echo "Archiving partition TR$TR/$PARTITION ..."

  cd $TR_PATH/$PARTITION/
  echo "Compressing TR$TR/$PARTITION using cmd 'tar chzf $TMP_ARCHIVE_PATH . 2>/dev/null', this may take time ..."
  tar chzf $TMP_ARCHIVE_PATH . 2>/dev/null 
  if [ $? != 0 ];then
    echo "ERROR : Compression of $TR/$PARTITION failed, error status returned by tar command is '$?' ..."
    echo "Restoring testrun ..."
    cd $NS_WDIR
    rm $TMP_ARCHIVE_PATH
    ERROR_FLAG=1
    return
  fi
}

validate_testrun_or_partition()
{
  ERROR_FLAG=1 		#initially setting this 1 if everything works fine reset this flag
  #summary.top must exist
  if [ ! -f $TR_PATH/$PARTITION/summary.top ];then
    echo "File $TR_PATH/$PARTITION/summary.top does not exist, skipping $TR_PATH/$PARTITION archive process."
    return 
  fi
  #Must not be already archived
  if [ -f $ARCHIVE_PATH ];then
    echo "$TR/$PARTITION is already archived."
    return
  fi
  
  #Check if test is running. Do not archive running test.
  nsu_show_netstorm | grep -w $TR 1>/dev/null 2>/dev/null
  if [ $? -eq 0 ]; then   #test is running
    if [ $P_FLAG -eq 1 ];then
      CUR_PARTITION=`awk -F '=' '/CurPartitionIdx/ {print $2}' $NS_WDIR/logs/TR$TR/.curPartition`
      if [ "X$CUR_PARTITION" = "X$PARTITION" ]; then
        echo "Partition $PARTITION is running. Cannot archive this partition"
        return
      fi
    else
      echo "TR $TR is running, skipping TR $TR"
      return 
    fi
  fi
  ERROR_FLAG=0		#resetting this flag
}

archive_partition()
{
  ERROR_FLAG=0
  #Check if test run exists
  TR_PATH="$NS_WDIR/logs/TR$TR"
  PARTITION_PATH="$NS_WDIR/logs/TR$TR/$PARTITION"
  if [ ! -d $PARTITION_PATH ]; then
    echo "$PARTITION_PATH directory does not exist"
    return
  fi
  #Check if test run in nd enabled
  check_nd_test

  #Check if multidisk is enbaled in test
  check_multidisk_path
  if [ $ERROR_FLAG -eq 1 ];then
    return
  fi

  ARCHIVE_PATH="$TR_PATH/$PARTITION/archive$PARTITION.tar.gz"
  TMP_ARCHIVE_PATH="$NS_WDIR/logs/TR$TR/archive$PARTITION.tar.gz"
  ERROR_ARCHIVE_PATH="$PARTITION_PATH/archive${PARTITION}_${$}.tar.gz"
  
  validate_testrun_or_partition
  if [ $ERROR_FLAG -eq 1 ];then
   return
  fi

  #Check is enough space is available 
  chk_disk_free

  #tar command returns error status if broken links are present in directory.
  #Hence removing broken links
  check_and_delete_broken_links
  if [ $ERROR_FLAG -eq 1 ];then
    return
  fi

  make_tar
  if [ $ERROR_FLAG -eq 1 ];then
    return
  fi
 
  #Drop database tables
  remove_database

  #Update summary.top, because GUI reads is to know if TR is archived
  update_summary_top

  #Update .partition_info.txt files
  update_partition_links
 
  #Rename scripts directory because we dont want to delete it.
  #Hidden files are not deleted by command rm *

  if [ $ERROR_FLAG -eq 1 ];then
    echo "There are some errors so not deleting data and creating archive on path : $ERROR_ARCHIVE_PATH"
    mv $TMP_ARCHIVE_PATH $ERROR_ARCHIVE_PATH
    rm $NS_WDIR/logs/TR$TR/$PARTITION/.summary.top
    return
  fi

  if [ $PREV_PARTITION -eq 0 ];then
    mv $TR_PATH/$PARTITION/scripts $TR_PATH/$PARTITION/.scripts
  fi
  
  delete_data_associated_to_tr_or_partition

  #move tar and other preserved files
  move_preserved_data
  echo "        Partition $TR/$PARTITION archived successfully."
  echo "	Total size of $TR/$PARTITION after archive is `du -hs $TR_PATH/$PARTITION | awk '{print $1}'`"
  echo ""
}

delete_data_associated_to_tr_or_partition()
{
  echo "Deleting data in directory $TR_PATH/$PARTITION ..."
  rm -rf $TR_PATH/$PARTITION/*

  echo "Deleting multidisk paths if exist ..."
  for ((i=0;i<${#PATH_ARRAY[@]};i++))
  do
    echo "Deleting directory ${PATH_ARRAY[$i]}/TR$TR/$PARTITION/ ..."
    rm -rf ${PATH_ARRAY[$i]}/TR$TR/$PARTITION/
  done
}

move_preserved_data()
{
  mv $TMP_ARCHIVE_PATH $ARCHIVE_PATH
  if [ -f $NS_WDIR/logs/TR$TR/$PARTITION/.summary.top ];then
    mv $NS_WDIR/logs/TR$TR/$PARTITION/.summary.top $NS_WDIR/logs/TR$TR/$PARTITION/summary.top
  fi
  if [ -d $NS_WDIR/logs/TR$TR/$PARTITION/.scripts ];then
    mv $NS_WDIR/logs/TR$TR/$PARTITION/.scripts $NS_WDIR/logs/TR$TR/$PARTITION/scripts
  fi
  cd $NS_WDIR

  #Change User/Group of archive same as summary.top file
  chown $OWNER $ARCHIVE_PATH
}

usage() {
 
 echo "$0 -n <TR number> -p <Partition> -r (if DB not to be deleted. Can be used with -p option only) | -s <TR number> -e <TR number>"
 echo "Example:"
 echo "$0 -n 1001 -p 20140821115559"
 echo "OR"
 echo "$0 -s 1001 -e 1234"
 echo "$0 -n <TR number>  -i (interactive mode - prompt once before proceeding)"
 exit 1
}

#While archiving/unarchiving same partitions in parallel, race condition may occur
#While archiving/unarchiving different partitions in parallel, we may get wrong value of remaining disk space.

#This function doesn't allow archive or unarchive shells to execute in parallel, even on different controllers.

check_if_prev_shell_running()
{
  PS_OUT=`ps -ef`

  #check if another gui for archive is running
  num_gui_ps=`echo "$PS_OUT" | grep "nsu_archive_trun.tomcat" | grep -v "grep" | wc -l`
  if [ $num_gui_ps -gt 1 ]; then
    echo "Another archive process is running on machine, hence Exiting"
    exit 1
  fi

  #check if any gui for unarchive is running
  num_gui_ps=`echo "$PS_OUT" | grep "nsu_unarchive_trun.tomcat" | grep -v "grep" | wc -l`
  if [ $num_gui_ps -gt 0 ]; then
    echo "Unarchive process is running on machine, hence Exiting"
    exit 1
  fi

  #check if another shell for archive is running
  num_shell_ps=`echo "$PS_OUT" | grep -v "nsu_archive_trun.tomcat" | grep "nsu_archive_trun" | grep -v "grep" | wc -l`
  if [ $num_shell_ps -gt 1 ]; then
    echo "Another archive process is running on machine, hence Exiting"
    exit 1
  fi
  
  #check if any shell for unarchive is running
  num_shell_ps=`echo "$PS_OUT" | grep -v "nsu_unarchive_trun.tomcat" | grep "nsu_unarchive_trun" | grep -v "grep" | wc -l`
  if [ $num_shell_ps -gt 0 ]; then
    echo "Unarchive process is running on machine, hence Exiting"
    exit 1
  fi
}

print_warning()
{
  if [ "X$I_FLAG" == "X0" ]; then
    return 
  fi

  echo -n "Do you want to proceed(yes/no):"
  read choice
  if [ "X$choice" == "Xno" ];then
   ERROR_FLAG=1
   echo "Your choice is no, so skipping this TR or partition"
   return 
  elif [ "X$choice" != "Xyes" ];then
   echo "Please type (yes/no)"
   print_warning
  fi
}

check_nd_test()
{
  if [ -f $TR_PATH/sorted_scenario.conf ]; then
    ISND=`grep ^NET_DIAGNOSTICS_SERVER $TR_PATH/sorted_scenario.conf | awk '{print $2}'`
  else
    ISND=`grep ^NET_DIAGNOSTICS_SERVER $TR_PATH/scenario | awk '{print $2}'`
  fi

  if [ "X$ISND" == "X" -o "X$ISND" == "X0" ];then
    ISND=0
  else
    ISND=1
  fi
}

check_multidisk_path()
{
  MULTIDISK_PATH=$TR_PATH/.multidisk_path   
  PATH_ARRAY=(`cat $MULTIDISK_PATH | tr -s '/'`)
  if [ ${#PATH_ARRAY[@]} -gt 0 ]; then
    MULTIDISK_FLAG=1
  fi
  echo "If archive is successfull, then all data for Test $TR will be deleted from following paths:"
  echo "$TR_PATH  ${PATH_ARRAY[@]}"
  print_warning
}

check_and_delete_broken_links()
{
  broken_links="`find $TR_PATH/$PARTITION/ -xtype l`" 

  if [ "X$broken_links" != "X" ];then
    echo "There are some broken links to proceed further you have to delete broken links mentioned below:"
    echo "$broken_links"
    echo "Program is going to delete these broken links for you."
    print_warning
    if [ $ERROR_FLAG -eq 1 ];then
      return
    fi
    rm $broken_links
  fi

  broken_links="`find $TR_PATH/$PARTITION/ -xtype l`" 
  if [ "X$broken_links" != "X" ];then
    echo "ERROR: could not delete broken links, skipping archive process for TR$TR/$PARTITION"
    ERROR_FLAG=1
  fi
}

archive_test_run()
{
  TR_PATH="$NS_WDIR/logs/TR$TR"

  if [ ! -d $TR_PATH ];then
    nsi_repo_download -t $TR 1>/dev/null 2>&1
  fi

  ERROR_FLAG=0
  #Check if test run exists
  if [ ! -d $TR_PATH ]; then
    echo "$TR_PATH directory does not exist"
    return
  fi

  #Check if test run in nd enabled
  check_nd_test

  #Check if multidisk is enbaled in test
  check_multidisk_path
  if [ $ERROR_FLAG -eq 1 ];then
    return
  fi


  ARCHIVE_PATH="$TR_PATH/archive$TR.tar.gz"
  TMP_ARCHIVE_PATH="$NS_WDIR/logs/archive$TR.tar.gz"
  ERROR_ARCHIVE_PATH="$TR_PATH/archive${TR}_$$.tar.gz"

  validate_testrun_or_partition
  if [ $ERROR_FLAG -eq 1 ];then
    return
  fi

  #Check is enough space is available 
  chk_disk_free

  #tar command returns error status if broken links are present in directory.
  #Hence removing broken links
  check_and_delete_broken_links
  if [ $ERROR_FLAG -eq 1 ];then
    return
  fi

  #Make tar only if TR is not uploaded(normal netstorm) on Repo OR Repo is configured(NSRepo client) 
  TR_UPLOAD_STATUS=`nsi_repo_get_tr_upload_status $TR` 
  REPO_LIB_STATUS=`nsi_repo_get_config` 
  if [ $TR_UPLOAD_STATUS == 0 -o "XX$REPO_LIB_STATUS" != "XX" ];then 
    make_tar
    if [ $ERROR_FLAG -eq 1 ];then
      return
    fi
  else
   mv $ARCHIVE_PATH $TMP_ARCHIVE_PATH 
  fi

  #Drop database tables
  remove_database

  #Update summary.top, because GUI reads is to know if TR is archived
  update_summary_top

  delete_data_associated_to_tr_or_partition
  
  #move tar and other preserved files
  move_preserved_data
 
  echo "	TR $TR archived successfully."
  echo "	Total size of $TR after archive is `du -hs $TR_PATH | awk '{print $1}'`"
}

########################################################
N_FLAG=0
S_FLAG=0
E_FLAG=0
P_FLAG=0
#Added -i option to fix bugid - 17333 (Merged from 4.1.5 against 17225)
I_FLAG=0
REMOVE_DB=1
ERROR_FLAG=0
MULTIDISK_FLAG=0

USERID=`whoami`
if [ "X$USERID" != "Xcavisson" ];then
  echo "You must be cavisson to execute this command"
  exit 1
fi

if [ "XX$NS_WDIR" == "XX" ];then
  echo "NS_WDIR is not exported."
  exit 1
fi

#Check if another archive or unarchive process is running
check_if_prev_shell_running

while getopts n:s:e:p:ri? c
do
  case $c in
	n) echo $OPTARG | egrep "[^0-9]" >/dev/null 2>&1
           if [ $? == 0 ];then
	      echo "TestRun must be an integer value."
              exit 1
           fi
           START_TR=$OPTARG
	   END_TR=$OPTARG
           TR=$OPTARG
	   N_FLAG=1;;
	s) echo $OPTARG | egrep "[^0-9]" >/dev/null 2>&1
           if [ $? == 0 ];then
              echo "Start TestRun must be an integer value."
              exit 1
           fi
           START_TR=$OPTARG
	   S_FLAG=1;;
	e) echo $OPTARG | egrep "[^0-9]" >/dev/null 2>&1
           if [ $? == 0 ];then
              echo "End TestRun must be an integer value."
              exit 1
           fi
           END_TR=$OPTARG
	   E_FLAG=1;;

        r) REMOVE_DB=0;;
        i) I_FLAG=1;;
	p) echo $OPTARG | egrep "[^0-9]" >/dev/null 2>&1
           if [ $? == 0 ];then
              echo "Partition must be an integer value."
              exit 1
           fi
           PARTITION=$OPTARG
	   P_FLAG=1;;
	?) usage ;;
  esac
done

if [ $S_FLAG != $E_FLAG ]; then
  echo "-s and -e must be used together"
  exit 1
fi

#partition option cannot be used with range
if [ \( $N_FLAG == 1 -o $P_FLAG == 1 \) -a \( $S_FLAG == 1 -o $E_FLAG == 1 \) ];then
  echo "-n and/or -p cannot be used with range of test runs" 
  exit 1
fi

#-r option can be used with partition only
if [ \( $P_FLAG == 0 \) -a \( $REMOVE_DB == 0 \) ]; then
  echo "-r option can be used with one partition only"
  exit 1
fi

if [ "X$START_TR" = "X" -o "X$END_TR" = "X" ]; then
  echo "Please provide test run number"
  exit 1
fi

if [ $START_TR -gt $END_TR ]; then
  echo "Start TR $START_TR should be greater than end TR $END_TR"
  exit 1
fi

#If partition flag is on, then archive partition and exit
if [ $P_FLAG -eq 1 ]; then
  archive_partition
  exit 0
fi

#Archive range of test runs
for TR in `seq $START_TR $END_TR`
do
  archive_test_run
  echo ""
done
