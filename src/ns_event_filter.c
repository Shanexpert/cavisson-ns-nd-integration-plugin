#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include "nslb_hash_code.h"
#include "ns_event_filter.h" 
#include "ns_exit.h"
#include "ns_error_msg.h"
#include <errno.h>

/*Duplicate as we dont wat to include ns_string.h & we can not put in ns_string.h as this is udes in script.c*/
#define EVENT_CLEAR    0

int elog_fd = -1;
int el_lfd  = -1;
EventDefinition *event_def = NULL;
EventDefinitionShr *event_def_shr_mem = NULL;
Str_to_hash_code_ex var_event_hash_func;
int num_total_event_id = -1;

#define MY_MALLOC(new, size, msg, index) {				\
    if (size < 0)							\
      {									\
	NS_EXIT(-1, "Trying to malloc a negative size (%d) for index %d", (int)size, index);	\
      }									\
    else if (size == 0)							\
      {									\
	new = NULL;							\
      }									\
    else								\
      {									\
	new = (void *)malloc( size );					\
	if ( new == (void*) 0 )						\
	{								\
	  NS_EXIT(-1, "Out of Memory: %s for index %d\n", msg, index);						\
	}								\
      }									\
  }

/*Open event log file & write header*/
void open_event_log_file(char *file_name, int mode, int write_header) {

  if(elog_fd > 0) return;

  if ((elog_fd = open(file_name, mode, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH)) == -1) {
    perror("EventLog:");
    //fprintf(stderr, "event logging writer: Error in opening logging file %s\n", file_name);
    NS_EXIT(-1, CAV_ERR_1000006, file_name, errno, nslb_strerror(errno));
  }

  if(write_header) {
     char header[] = "Time-Stamp|Event-ID|Severity|IP:NVM-ID:Session-ID:User-ID|"
		     "Data-Source-Type|Host|Attribute-Name|Attribute-Value|Description\n";
    if(write(elog_fd, header, strlen(header)) < 0) {
      perror("Header ELWrite:");
      NS_EXIT(-1, CAV_ERR_1000032, file_name, errno, nslb_strerror(errno));
    }
  }

  return;
}

/**
Purpose         : This method is to search an event using attributes, if event not found in the list then add node at the
		  end of list. If node found then update node and logged event 
Arguments       :
		 - Received event buffer
Return Value    :
		 0 - If new event occur . Event should logged
		 1 - If duplicate event occur. Event should not logged
		 3 - if event delete
		-1 - If any error
**/
/**
Purpose   : This method is to Add Node at the end of Events linked list and set the fields by extracting
	    fields of an event generated by system 
Arguments : 
	    event_tail - Pointer to tail of events linklist
	    event_value - Event value of an incomming Event
	    attr_value - Attribute value of an incomming event
	    state - state of an incomming event
	    last_event_time - time of last incomming event

Return Value : Head pointer of events node 
**/
static Events* add_event(Events *event_tail, char *event_value,
			 char *attr_value, int state, u_ns_ts_t last_event_time) {
  //NSDL2_LOGGING(NULL, NULL, "Method called");
  Events *tmp_event;
  
  MY_MALLOC(tmp_event, sizeof(Events), "Head Node of Linked List", -1);

  MY_MALLOC(tmp_event->event_value, strlen(event_value) + 1, "Event Value", -1);
  strcpy(tmp_event->event_value, event_value);

  MY_MALLOC(tmp_event->attr_value, strlen(attr_value) + 1, "Attribute Value", -1);
  strcpy(tmp_event->attr_value, attr_value);
    
  tmp_event->state = state;
    
  // Number of Event counts
  tmp_event->num_event = 0;
    
  // Last logged time
  tmp_event->last_event_time = last_event_time;
     
  tmp_event->next = NULL;

  if(event_tail == NULL) // There are no node in the linked list
    return tmp_event;
  else
    event_tail->next = tmp_event;
  return event_tail;
}

#if 0
static write_event_log() {
  int len;
  char event_buf[1024];
  len = sprintf(event_buf, "%02lu:%02lu:%02lu", (ts/1000) / 3600,
                                           ((ts/1000) % 3600) / 60,  
                                           ((ts/1000) % 3600) % 60);

  len = sprintf(event_buf, "%s|%lu|%s|%s:%d:%d:%d|%s|%s|%s|%s\n",
                               event_buf, 6, "Info",
                               "127.0.0.1", -1, -1, -1, "Core",
                               "-", "-", msg);

}
#endif

/*Chks duplicacy of events & filter those one for which filtering is enabled*/
int is_event_duplicate(u_ns_ts_t ts, int severity, char *event_val, char *event_id,
		      char *attr_val, int *hashcode_index, int idx) {
  Events *head_ptr, *node_ptr;
  int state;
  u_ns_ts_t last_event_time = 0;
  u_ns_ts_t cur_event_time; // This contains time of source of an event
   
  if(var_event_hash_func == NULL)
  { 
    //fprintf(stderr, "Warning: Event hash code function is not yet initialized\n");
    return -1;
  }

  // To get hash code index
  *hashcode_index = var_event_hash_func(event_id, strlen(event_id));
  if((*hashcode_index < 0) || (*hashcode_index >= num_total_event_id)) {
    fprintf(stderr, "Error: Incorrect Event. Hashcode for event id '%s' is out of range (%d)\n",
		     event_id, *hashcode_index);
    return -1;
  }

  if(idx == -1) return 0;  // I need only hash code of that id for logging events

  /* Filter ALL Events*/
  if(event_def_shr_mem[*hashcode_index].filter_mode == NS_EVENT_ALL_FILTER) {
    //NSDL2_LOGGING(NULL, NULL, "No Filtering, filter_mode = %d", event_def_shr_mem[*hashcode_index].filter_mode);
    return 1;
  }

  // No filtering, so do not check or add in the linked list
  if(event_def_shr_mem[*hashcode_index].filter_mode == NS_EVENT_NO_FILTER) {
    //NSDL2_LOGGING(NULL, NULL, "No Filtering, filter_mode = %d", event_def_shr_mem[*hashcode_index].filter_mode);
    return 0;
  }

  cur_event_time = last_event_time = ts; 
  head_ptr = event_def_shr_mem[*hashcode_index].event_head[idx];
  state = severity;

  // There are no events for this event
  if(head_ptr == NULL) {
    //NSDL2_LOGGING(NULL, NULL, "First Event Added in the list");
    event_def_shr_mem[*hashcode_index].event_head[idx] = add_event(head_ptr, event_val, attr_val, state, last_event_time);
    return 0;
  }

  // Now find if any event there in the linked list
  node_ptr = head_ptr; 
  while(node_ptr != NULL) {
    // Check attribute value in the incoming event and the node in the linked list
    if(strcmp(node_ptr->attr_value, attr_val) != 0)  {
      //NSDL2_LOGGING(NULL, NULL, "Not Matching Event occured");
      if(node_ptr->next == NULL) {
	add_event(node_ptr, event_val, attr_val, state, last_event_time);
	break;
      }
      node_ptr = node_ptr->next;
      continue;
    }
    
    // Filtering apply based on attribute and state of an event
    if(event_def_shr_mem[*hashcode_index].filter_mode == NS_EVENT_STATE_FILTER) {
      if(node_ptr->state == state) {
	//NSDL2_LOGGING(NULL, NULL, "same Event Occures, state = %d", state);
	return 1;
      } else { // update fields of state events with incomming event
	//NSDL2_LOGGING(NULL, NULL, "Different Event State Occur : Logged Event");
	if(state == EVENT_CLEAR) {
	  event_def_shr_mem[*hashcode_index].event_head[idx] = delete_event(node_ptr, attr_val/*state*/);
	  return 3;
	}

	//update last_time and set num to 0
	node_ptr->num_event = 0;
	node_ptr->last_event_time = 0;
	node_ptr->state = state; 
	return 0;
      }
    } else { // mode 2 and 3
      if(node_ptr->state != state) {  // State is changing, so it is not duplicate
	//NSDL2_LOGGING(NULL, NULL, "Different Event State Occur : Logged Event");
	if(state == EVENT_CLEAR) {
	  event_def_shr_mem[*hashcode_index].event_head[idx] = delete_event(node_ptr, attr_val);
	  return 3;
	}

	node_ptr->num_event = 0;
	node_ptr->last_event_time = 0;
	node_ptr->state = state;
	return 0;
      }
      // Filtering apply based on XXX count. 
      if(event_def_shr_mem[*hashcode_index].filter_mode == NS_EVENT_COUNT_FILTER) {
	//count = atoi(event_def_shr_mem[hashcode_index].mode_based_param);  // Keep it in int as init time
	if(node_ptr->num_event < event_def_shr_mem[*hashcode_index].mode_based_param) {
	  node_ptr->num_event++;
	  //NSDL2_LOGGING(NULL, NULL, "Event count = %d", node_ptr->num_event);
	  return 1;     
	}
	if(node_ptr->num_event >= event_def_shr_mem[*hashcode_index].mode_based_param) {  // it should be == but check for >=
	  //NSDL2_LOGGING(NULL, NULL, "Event will be logged After %d count", node_ptr->num_event);
	  node_ptr->num_event = 0;
	  node_ptr->last_event_time = 0;
	  return 0;
	}
      } else if(event_def_shr_mem[*hashcode_index].filter_mode == NS_EVENT_TIME_FILTER) {// Filtering apply based on time. 
	if(event_def_shr_mem[*hashcode_index].mode_based_param <=
		    (cur_event_time - node_ptr->last_event_time)) {
	  //NSDL2_LOGGING(NULL, NULL, "Event logged After %ld secs", event_def_shr_mem[*hashcode_index].mode_based_param.event_time);
	  node_ptr->last_event_time = cur_event_time;
	  return 0;
	}
	else
	  return 1;
      } else { // Invalid mode
	fprintf(stderr, "Invalid Filter Mode for id %s\n", event_id);
	return -1;
      }
    } // end of else
  }  //end of while

  return 0;
}

/**  
 *  Purpose         : This method is to free memory of an event node 
 *  Arguments       :
 *                   - pointer to events structure
 *                   Return Value    : None
 *                    **/
static void free_event_struct(Events *to_free) {
  free(to_free->event_value);
  free(to_free->attr_value);
  free(to_free);
}

/**
Purpose         : This method is to delete a node from linked list if event state is 'CLEAR'
Arguments       :
		 - Head pointer
		 - attribute value of an event
Return Value    : Head pointer to event linked list
**/
Events *delete_event(Events *head, char * attr_value) {

  if(head == NULL)
    return NULL;

  if(strcmp(head->attr_value, attr_value) == 0) {
    Events *tmp;
    tmp = head->next;
    free_event_struct(head);
    return tmp;
  }
  head->next = delete_event(head->next, attr_value);
  return head;
}
