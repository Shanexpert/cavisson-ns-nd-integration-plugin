/******************************************************************
 * Name    : ns_monitor_init.h 
 * Author  : Himanshu Singhal
 * Purpose : This file contains declaration of macros ,methods and structure. 
 * Note:
 * Modification History:
 * 06/Aug/2020 - Initial Version
*******************************************************************/

#include "util.h"
#include <stdbool.h>
#include "nslb_get_norm_obj_id.h"
#include "ns_dynamic_vector_monitor.h"
#include "ns_custom_monitor.h"

// Macros for FLAG

#define MINFO_FLAG_TIER_GROUP              0x0001  // If flag is set i.e. monitor is applied on tier group. Else by default it is on tier name
#define MINFO_FLAG_ANY_SERVER              0x0002  // Monitor is applied on any server.
#define MINFO_FLAG_DEST_TIER_ANY_SERVER    0x0004  // Monitor is applied on destination tier any server.
#define MINFO_FLAG_APP_NAME                0x0008  // If flag is set i.e. monitor appname is other than default.
#define MINFO_FLAG_EXCLUDE_TIER            0x0010  // If flag is set i.e. exclude-tier tag is present in JSON.
#define MINFO_FLAG_SPECIFIC_SERVER         0x0020  // If flag is set i.e. specific-server tag is present in JSON.
#define MINFO_FLAG_EXCLUDE_SERVER          0x0040  // If flag is set i.e. exclude-server tag is present in JSON.
#define MINFO_FLAG_AGENT_TYPE              0x0080  // If flag is set i.e. agent-type tag is present in JSON.


// MACRO for MONITOR TYPE

#define MTYPE_CHECK                     0   // for check monitors
#define MTYPE_SERVER_SIGNATURE          1   // for server signature
#define MTYPE_STD                       2   // for standard monitors
#define MTYPE_LOG                       4   // for log monitors
#define MTYPE_CUSTOM_GDF                5   // for custom gdf monitors
#define MTYPE_BATCH_JOB                 7   // for batch job monitors


// MACROS for CHECK MONITOR json parsing

#define PROCESS_CHECK_MON                   1
#define PROCESS_BATCH_JOB_MON               2
#define PROCESS_SERVER_SIGNATURE_MON        3

// MACROS for LOG MONITOR json parsing

#define PROCESS_LOG_PATTERN_MON             1
#define PROCESS_GET_LOG_FILE_MON            2
#define PROCESS_LOG_DATA_MON                3

// MACROS for CUSTOM GDF MONITOR and STANDARD MONITOR json parsing

#define PROCESS_CUSTOM_GDF_MON              1
#define PROCESS_STD_MON                     1

// MACROS for status of montior

#define MJ_QUEUED                              1
#define MJ_SUCCESS                             2
#define MJ_STOPPED                             3
#define MJ_FAILURE                             4

// MACROS for SM MODE

#define SM_RUN_ONCE_MODE                       1
#define SM_DURATION_MODE                       2

// MACROS for Monitor Type In JSON

#define MJ_ADDED                               0
#define MJ_MODIFIED                            1
#define MJ_DELETED                             2


#define NONE                                   0
#define INCLUDE                                1
#define INCLUDE_ANY                            2
#define EXCLUDE                                3
#define EXCLUDE_ANY                            4
 
#define DELTA_BIT_VECTOR_ENTRIES               100
extern NormObjKey *g_monid_hash;   //used for normalized table of g_mon_id

extern int total_mon_config_list_entries;  //used to store the total no. of entries present in MonConfigList struct.
extern int max_mon_config_list_entries;


typedef struct
{
  char name[128];
  int idx;
  char type;
}StringWithType;

// This structure stores the count and array
typedef struct
{
  int count;
  char **list;
}ArrInfo;

typedef struct
{
  char status;                      // Contain flag to denote status (queued , request send(cm_init sending), 1) success, 2)failure)
  char message[2048];               // Return message  //<monId>:status=ERROR;msg=error message\n  //overwrite
  int mon_id;                       // generated by Cav Main
}MonId;

typedef struct
{
  NSLB_MP_COMMON;
  // Monitor Status related variables
  int mon_err_count;                // This will tell for how many server monitor is not applied
  int count;                        // Number of servers where this monitor is applied
  MonId *mon_id_struct;             // Int array having list of g_mon_id of all monitor
  int total_mon_id_index;           // remove
  int max_mon_id_index;

  //Server related Information
  union
  {
    char *tier_name; 
    char *tier_group;
  };
  union
  {
    int tier_idx;
    int tier_group_idx;
  };
  int mon_info_flags;               // This flag is used for TierGroup, Specific Server, Exclude Server, Appname
  ArrInfo *exclude_server;             
  ArrInfo *specific_server;
  ArrInfo *dest_tier_server;
  ArrInfo *exclude_tier;
    
  //Monitor options
  ArrInfo *kube_ip_appname;         // this structure used for storing appname of IP Stat monitor which is passed in options 
  char *app_name;                   // If appname is default then it is NULL
  char *g_mon_id;                   // id of monitor recieved form UI
  char *pgm_type;                   // stores the program type such as  java,linux,c etc. 
  char *use_agent;                  // this is local or remote 
  char *vectorReplaceFrom;
  char *vectorReplaceTo;
  char *javaClassPath;
  char *javaHome;                   
  char *init_vector_file;
  char *config_json;
  char *mon_name;  
  char *instance_name;              
  char *gdf_name; 
  char *old_options;                // holds the argument or options required to run a program
  char *options;                    // holds the argument or options required to run a program
  char *os_type;                    // this stores the os_type of machine
  char *namespace;                  //this is used in kubernetes monitors
  char *cmon_pod_pattern;           //this is for kubernetes monitors and we set default by "cmon-" we assume that pod prefix will starts this
  char *cm_init_buffer;             // Store cm_init_buffer message
  char tier_server_mapping_type;
  char agent_type;                  // agent type may cmon or BCI in case of config json default is connect to cmon
  char metric_priority;
  char skip_breadcrumb_creation;    // used for metric hierarchy prefix 
  char mon_type;                    //this stores the type of monitor
  char is_process;
  int sm_mode;                      // this will be 1 or 2 if 1 means dont need to retry and if 2 we have to retry if fails. 
  int run_opt;                      // run option which is 2 in most the cases
  int frequency;                    // monitor interval in msec
  JSON_info *json_info_ptr;
  int std_mon_idx;
}MonConfig;

// This is made due to type modiefied because we have to match the previous entries of monitor with new so we first store the json in MonConfig
// struct then we point the mon_config ptr in MonitorConfigList or we modified the previous one if it is not new.
typedef struct 
{
  MonConfig *mon_config;

}MonConfigList;

nslb_mp_handler mon_config_pool;
MonConfigList *mon_config_list_ptr;

extern void mj_read_global_json(char *json_file);
extern int mj_read_json_dir_create_config_struct(char* directory_path);
extern int mj_read_json_and_save_struct(char *json_file, int runtime_flag);

extern void start_monitors_on_all_servers();
extern int apply_monitor(char *vector_name, int server_id, int tier_id, int mon_info_index, char *app_name, int runtime_flag);
extern void mj_apply_monitors_on_autoscaled_server(char *vector_name, int server_id, int tier_id, char *app_name);

extern void mj_increase_server_count(int mon_info_index);
extern void mj_decrease_server_count(int mon_info_index, int mon_id,int tid);
extern void mj_replace_char_and_update_pod_name(char *vector_name, char *prgrm_args, char *pod_name, char *app_name, char *monitor_name,
                                                char *tmp_instance_name);
extern void free_mon_config_structure(MonConfig *mon_config, int flag);

extern void mj_delete_specific_server_hash_entry(CM_info *cus_mon_ptr);
