/*
 * This is sample code generated by rpcgen.
 * Code is modified by Neeraj and Achit for NetStorm
 */


#include <regex.h>

#include "url.h"
#include "ns_byte_vars.h"
#include "ns_nsl_vars.h"
#include "ns_search_vars.h"
#include "ns_cookie_vars.h"
#include "ns_check_point_vars.h"
#include "rstat.h"
#include "nslb_time_stamp.h"
#include "ns_static_vars.h"
#include "ns_msg_def.h"
#include "ns_check_replysize_vars.h"
#include "ns_error_codes.h"
#include "ns_server.h"
#include "util.h"
#include "ns_gdf.h"
#include "server_stats.h"
#include "ns_gdf.h"
#include "ns_log.h"

static int running_as_tool = 0;
static int interval = 1000;
static int time_out = 2000;
static int num_servers = 0;

static CLIENT **rstat_clnt;
static statstime **rstat_last;
static char **rstat_hosts;

#define RSTAT_INIT_NOT_DONE   0
#define RSTAT_INIT_DONE       1

#ifdef RSTAT_TEST
#undef NSDL1_MON
#define NSDL1_MON printf

FILE *gui_fp;   // This is to resolve when building rstat_client (Test program)

#endif

void show_rstat(Server_stats_gp *rstat_rep)
{
  // printf ("cpuUser=%6.2f, cpuNice=%6.2f, cpuSystem=%6.2f, cpuTotalBusy=%6.2f\n",
    // (double)((double)ntohl(rstat_rep->cpuUser)/100.0),(double)((double)ntohl( rstat_rep->cpuNice)/100.0), (double)((double)ntohl(rstat_rep->cpuSys)/100.0),(double)((double)ntohl(rstat_rep->cpuTotalBusy)/100.0));
  printf ("cpuUser=%6.2f, cpuSystem=%6.2f, cpuTotalBusy=%6.2f\n",
    (double)((double)(rstat_rep->cpuUser)/100.0), (double)((double)(rstat_rep->cpuSys)/100.0),(double)((double)(rstat_rep->cpuTotalBusy)/100.0));

//  printf ("dk_xfer[0]=%d, dk_xfer[1]=%d, dk_xfer[2]=%d, dk_xfer[3]=%d\n", rstat_rep->dk_xfer[0], rstat_rep->dk_xfer[1], rstat_rep->dk_xfer[2], rstat_rep->dk_xfer[3]);

  printf ("pageIn=%6.2f, pageOut=%6.2f, swapIn=%6.2f, swapOut=%6.2f\n",
    (double)((double)(rstat_rep->pageIn)),(double)((double)( rstat_rep->pageOut)),(double)((double)( rstat_rep->swapIn)),(double)((double)( rstat_rep->swapOut)));

  printf ("InEthPkts=%6.2f, InEthErrs=%6.2f, OutEthErrs=%6.2f, if_collisions=%6.2f, OutEthPkst=%6.2f\n",
    (double)((double)(rstat_rep->InSegs)),(double)((double)( rstat_rep->InErrs)),(double)((double)( rstat_rep->OutRsts)),(double)((double)( rstat_rep->collisions)),(double)((double)(rstat_rep->OutSegs)));

  printf ("interrupts=%6.2f, v_swtch=%6.2f, loadAvg1m=%6.2f, loadAvg5m=%6.2f, loadAvg15m=%6.2f\n\n",
(double)((double)(rstat_rep->interrupts)),(double)((double)(rstat_rep->v_swtch)),(double)((double)(rstat_rep->loadAvg1m)/100.0),(double)((double)( rstat_rep->loadAvg5m)/100.0),(double)((double)(rstat_rep->loadAvg15m)/100.0));

}

static void
fill_rstat_server_stats_gp (int host_id, statstime *rstat_cur, Server_stats_gp *server_stats_proc)
{
statstime *rstat_prev;
unsigned int total_cpu_cur, total_cpu_prev, total_cpu_delta;
unsigned int intval;
unsigned int cpuIdle;
int usec_diff;
 unsigned int result; 
#if 0
double intval;
double user;     /* percentages over the interval */
double system;
double wait;
double idle;
ulong ncpus;	/* number of CPUs */
#endif

  rstat_prev = rstat_last[host_id];
  total_cpu_prev = rstat_prev->cp_time[0] + rstat_prev->cp_time[1] + rstat_prev->cp_time[2] + rstat_prev->cp_time[3];
  total_cpu_cur = rstat_cur->cp_time[0] + rstat_cur->cp_time[1] + rstat_cur->cp_time[2] + rstat_cur->cp_time[3];
  total_cpu_delta = total_cpu_cur - total_cpu_prev;

  //usec_diff must be signed int
  usec_diff = (rstat_cur->curtime.tv_usec - rstat_prev->curtime.tv_usec);
  usec_diff /= 1000;
  intval = (rstat_cur->curtime.tv_sec - rstat_prev->curtime.tv_sec) * 1000 + usec_diff;

  if (intval <= 0) intval = 1;

  //printf ("intval = %d\n", intval);

  // Notes:
  // cp_time[0] is Time spent running non-kernel code. (user time),
  // cp_time[1] is nice time, cp_time[2] is system time, cp_time[3] is idle time
  // CPU % are multiplied with 100 to store upto 2 decimal digits in int variable
  // E.g 95.45% is stores is 9545
  if(total_cpu_delta == 0)  // Need to handle this case. How to calcualte %
    printf("total_cpu_delta is 0\n");
  else
  {
    result = (((rstat_cur->cp_time[0] - rstat_prev->cp_time[0]) * 100)*100)/total_cpu_delta;
    server_stats_proc->cpuUser = /* htonl */(result);
#ifndef RSTAT_TEST
    update_gdf_data(server_stats_gp_idx, 0, host_id, 0, (unsigned long long)result);
#endif

    // server_stats_proc->cpuNice = htonl((((rstat_cur->cp_time[1] - rstat_prev->cp_time[1]) * 100)*100)/total_cpu_delta);

    result = (((rstat_cur->cp_time[2] - rstat_prev->cp_time[2]) * 100)*100)/total_cpu_delta;
    server_stats_proc->cpuSys = /* htonl */(result);
#ifndef RSTAT_TEST
    update_gdf_data(server_stats_gp_idx, 1, host_id, 0, (unsigned long long)result);
#endif

    cpuIdle = (((rstat_cur->cp_time[3] - rstat_prev->cp_time[3]) * 100)*100)/total_cpu_delta;

    result = (10000 - cpuIdle);
    server_stats_proc->cpuTotalBusy = /* htonl */(result);
#ifndef RSTAT_TEST
    update_gdf_data(server_stats_gp_idx, 2, host_id, 0, (unsigned long long)result);
#endif
  }

#if 0
  printf ("Total delta =%lu \n", total_cpu_delta);
  intval = (rstat_cur->curtime.tv_sec +
			rstat_cur->curtime.tv_usec/1000000.0) -
			(rstat_prev->curtime.tv_sec +
			rstat_prev->curtime.tv_usec/1000000.0);
  printf ("Total sec =%6.3f \n", intval);

		/* units are clock ticks */
		user = (rstat_cur->cp_time[0] - rstat_prev->cp_time[0]) / intval;
		system = (rstat_cur->cp_time[2] - rstat_prev->cp_time[2]) / intval;
		wait = (rstat_cur->cp_time[1] - rstat_prev->cp_time[1]) / intval;
		idle = (rstat_cur->cp_time[3] - rstat_prev->cp_time[3]) / intval;
		/* adds up to hz per CPU but allow for rounding and trunc */
		ncpus = (user + system + wait + idle) / (99);
		if (ncpus == 0) {
		     ncpus = 1;      /* save/resume or date set problem */
		}
		user /= ncpus;
		system /= ncpus;
		wait /= ncpus;
		idle /= ncpus;

  printf ("user=%3.0f sys=%3.0f wait=%3.0f idle=%3.0f cpu=%lu\n", user, system, wait, idle, ncpus);
  printf ("Total df_xfer[0]=%lu df_xfer[1]=%lu df_xfer[2]=%lu df_xfer[3]=%lu\n",
	rstat_cur->dk_xfer[0],
	rstat_cur->dk_xfer[1],
	rstat_cur->dk_xfer[2],
	rstat_cur->dk_xfer[3]
	/*rstat_cur->dk_xfer[0] - rstat_prev->dk_xfer[0],
	rstat_cur->dk_xfer[1] - rstat_prev->dk_xfer[1],
	rstat_cur->dk_xfer[2] - rstat_prev->dk_xfer[2],
	rstat_cur->dk_xfer[3] - rstat_prev->dk_xfer[3]*/
	);
#endif
  // Calculate Page in and out (per second)
  result = (rstat_cur->v_pgpgout - rstat_prev->v_pgpgout) * 1000 /intval;
  server_stats_proc->pageOut = /* htonl */(result);
#ifndef RSTAT_TEST
  update_gdf_data(server_stats_gp_idx, 4, host_id, 0, (unsigned long long)result);
#endif

  result = (rstat_cur->v_pgpgin - rstat_prev->v_pgpgin) * 1000 /intval;
  server_stats_proc->pageIn = /* htonl */(result);
#ifndef RSTAT_TEST
  update_gdf_data(server_stats_gp_idx, 3, host_id, 0, (unsigned long long)result);
#endif

  // Calculate Swap in and out (per second)
  result = (rstat_cur-> v_pswpin - rstat_prev->v_pswpin) * 1000 /intval;
  server_stats_proc->swapIn = /* htonl */(result);
#ifndef RSTAT_TEST
  update_gdf_data(server_stats_gp_idx, 5, host_id, 0, (unsigned long long)result);
#endif

  result = (rstat_cur-> v_pswpout - rstat_prev->v_pswpout) * 1000 /intval;
  server_stats_proc->swapOut = /* htonl */(result);
#ifndef RSTAT_TEST
  update_gdf_data(server_stats_gp_idx, 6, host_id, 0, (unsigned long long)result);
#endif

  // Calculate Interuupts (per second)
  result = (rstat_cur->v_intr - rstat_prev->v_intr) * 1000 /intval;
  server_stats_proc->interrupts = /* htonl */(result);
#ifndef RSTAT_TEST
  update_gdf_data(server_stats_gp_idx, 9, host_id, 0, (unsigned long long)result);
#endif

  // Caluclates Switchs (per second)
  result = (rstat_cur->v_swtch - rstat_prev->v_swtch) * 1000 /intval;
  server_stats_proc->v_swtch = /* htonl */(result);
#ifndef RSTAT_TEST
  update_gdf_data(server_stats_gp_idx, 18, host_id, 0, (unsigned long long)result);
#endif

  //Calculate Input Packets
  result = (rstat_cur->if_ipackets - rstat_prev->if_ipackets) * 1000 /intval;
  server_stats_proc->InSegs = /* htonl */(result);
#ifndef RSTAT_TEST
  update_gdf_data(server_stats_gp_idx, 13, host_id, 0, (unsigned long long)result);
#endif

  //Calculate Output Packets
  result = (rstat_cur->if_opackets - rstat_prev->if_opackets) * 1000 /intval;
  server_stats_proc->OutSegs = /* htonl */(result);
#ifndef RSTAT_TEST
  update_gdf_data(server_stats_gp_idx, 14, host_id, 0, (unsigned long long)result);
#endif

  //Calculate Input Errors
  result = (rstat_cur->if_ierrors - rstat_prev->if_ierrors) * 1000 /intval;
  server_stats_proc->InErrs = /* htonl */(result);
#ifndef RSTAT_TEST
  update_gdf_data(server_stats_gp_idx, 15, host_id, 0, (unsigned long long)result);
#endif

  //Calculate Output Errors
  result = (rstat_cur->if_oerrors - rstat_prev->if_oerrors) * 1000 /intval;
  server_stats_proc->OutRsts = /* htonl */(result);
#ifndef RSTAT_TEST
  update_gdf_data(server_stats_gp_idx, 16, host_id, 0, (unsigned long long)result);
#endif

  //Calculate Collisions
  result = (rstat_cur->if_collisions - rstat_prev->if_collisions) * 1000 /intval;
  server_stats_proc->collisions = /* htonl */(result);
#ifndef RSTAT_TEST
  update_gdf_data(server_stats_gp_idx, 17, host_id, 0, (unsigned long long)result);
#endif

  //Calculate Average (Code to be checked later)
#if 0
  server_stats_proc->loadAvg1m  = /* htonl */(rstat_cur->avenrun[0] - rstat_prev->avenrun[0]);
  server_stats_proc->loadAvg5m  = /* htonl */(rstat_cur->avenrun[1] - rstat_prev->avenrun[1]);
  server_stats_proc->loadAvg15m = /* htonl */(rstat_cur->avenrun[2] - rstat_prev->avenrun[2]);
#endif
  // Load Average is send as muliple of 100
  result = (rstat_cur->avenrun[0] * 100)/256;
  server_stats_proc->loadAvg1m  = /* htonl */(result);
#ifndef RSTAT_TEST
  update_gdf_data(server_stats_gp_idx, 10, host_id, 0, (unsigned long long)result);
#endif

  result = (rstat_cur->avenrun[1] * 100)/256;
  server_stats_proc->loadAvg5m  = /* htonl */(result);
#ifndef RSTAT_TEST
  update_gdf_data(server_stats_gp_idx, 11, host_id, 0, (unsigned long long)result);
#endif

  result = (rstat_cur->avenrun[2] * 100)/256;
  server_stats_proc->loadAvg15m = /* htonl */(result);
#ifndef RSTAT_TEST
  update_gdf_data(server_stats_gp_idx, 12, host_id, 0, (unsigned long long)result);
#endif
}

void save_rstat_data(int host_id, statstime *rstat_rep)
{
  if (rstat_rep)
    memcpy(rstat_last[host_id], rstat_rep, sizeof(statstime));
}

// This is in rstat_clnt.c
extern statstime * rstatproc_stats_3x(void *argp, CLIENT *clnt, struct timeval *timeout);

statstime *get_rstat_data(int host_id, int init_done, int interval, Server_stats_gp *server_rstats, u_int time_out)
{
statstime  *rstat_rep;
// char *rstatproc_stats_3_arg;
int rstatproc_stats_3_arg;

static struct timeval rstat_timeout ;

   rstat_timeout.tv_sec = time_out/1000;
   rstat_timeout.tv_usec = 0;  // Currently we keep this 0

  if(rstat_clnt[host_id] == NULL)
  {
#ifdef RSTAT_TEST
    printf("rstat_clnt is NULL for server %s", rstat_hosts[host_id]);
#else
    NSDL1_MON(NULL, NULL, "rstat_clnt is NULL for server %s", rstat_hosts[host_id]);
#endif
    return NULL;
  }
  rstat_rep = (statstime *)rstatproc_stats_3x(&rstatproc_stats_3_arg, rstat_clnt[host_id], &rstat_timeout);
  if (rstat_rep == (statstime *) NULL)
  {
    fprintf(stderr, "Error in rstatproc_stats_3x host id = %d\n", host_id);
    clnt_perror (rstat_clnt[host_id], "call failed");
    return (NULL);
  }
  if(init_done == RSTAT_INIT_DONE)
    fill_rstat_server_stats_gp(host_id, rstat_rep, server_rstats);
    //process_rstat_data(host_id, rstat_rep, Server_stats_gp, interval);
  // Save must be done after process
  save_rstat_data(host_id, rstat_rep);
  return (rstat_rep);
}

// Currently not sending Time out
int init_rstat(int num_hosts, char **hosts)
{
int host_id;
Server_stats_gp server_stats; // this is used to get data but it not used as in init we get data for saving first snap shot

  num_servers = num_hosts;
  
  if(num_hosts) {
    rstat_clnt = malloc(sizeof(char *) * num_hosts);
    rstat_last = malloc(sizeof(char *) * num_hosts);
    rstat_hosts = malloc(sizeof(char *) * num_hosts);
  }

  for (host_id = 0; host_id < num_hosts; host_id++)
  {
    rstat_last[host_id] = malloc(sizeof(statstime));

    rstat_hosts[host_id] = malloc(strlen(hosts[host_id]) + 1);
    strcpy(rstat_hosts[host_id], hosts[host_id]);

    if(running_as_tool)
      printf("Doing init_rstat for %s\n", rstat_hosts[host_id]);

    rstat_clnt[host_id] = clnt_create(rstat_hosts[host_id], RSTATPROG, RSTATVERS_TIME, "udp");
    if (rstat_clnt[host_id] == NULL)
    {
      char rstat_err[1024];
      sprintf(rstat_err, "Error in connecting to rstatd (%s)", rstat_hosts[host_id]);
      clnt_pcreateerror (rstat_err);
      continue; // Continue so that we can do other servers
    }
    statstime  *rstat_rep;

    // For initialization, pass default timeout of 2000 milli-secs
    // We are calling get_rstat_data one extra time as first two times, it take longer time than normal
    rstat_rep = get_rstat_data(host_id, RSTAT_INIT_NOT_DONE, 0, &server_stats, 2000);
    rstat_rep = get_rstat_data(host_id, RSTAT_INIT_NOT_DONE, 0, &server_stats, 2000);
    save_rstat_data(host_id, rstat_rep);
  }
  if(running_as_tool)
    printf ("Init Done\n");
  return 0;
}

int close_rstat()
{
  int i;

  for (i = 0; i < num_servers; i++)
    clnt_destroy (rstat_clnt[i]);
  return 0;
}

// This is fill fixed value for testing of RTG GUI mapping of index to graphs
int
get_rstat_data_for_all_servers_test(int num_servers, Server_stats_gp *server_stats)
{
int host_id;
unsigned int *ptr;
int var, varValue;
int numVars = (sizeof(Server_stats_gp))/4;

  for (host_id = 0; host_id < num_servers; host_id++)
  {
    ptr = (unsigned int *)(&server_stats[host_id]);
    ptr = (unsigned int *)((char *)ptr + 64);
    // printf("ptr = %x, host_id = %d, numVars = %d\n", ptr, host_id, numVars);
    for(var = 0; var < numVars; var++)
    {
      varValue = (100 * (host_id + 1)) + var;
      // printf("ptr = %x, var = %d, varValue = %d\n", ptr, var, varValue);
      *ptr = /* htonl */(varValue);
      ptr++;
    }
    if(running_as_tool)
      show_rstat(&server_stats[host_id]);
  }
  // printf("Done\n");
  return 0;
}



int
get_rstat_data_for_all_servers(int num_servers, Server_stats_gp *server_stats)
{
  u_ns_ts_t stime;
  u_ns_ts_t total_time_taken;
  int host_id;

  Server_stats_gp *server_stats_local_ptr = server_stats;

  /* Neeraj - This used for testing of RTG GUI with fixed data
  get_rstat_data_for_all_servers_test(num_servers, server_stats);
  return 0;
  */

  total_time_taken = 0;
  for (host_id = 0; host_id < num_servers; host_id++)
  {
    if(running_as_tool)
      printf("Getting data from %s\n", rstat_hosts[host_id]);
    stime = get_ms_stamp();
    get_rstat_data(host_id, RSTAT_INIT_DONE, interval, server_stats_local_ptr, time_out);
    stime = get_ms_stamp() - stime;
    total_time_taken +=  stime;
    if(running_as_tool == 0)  // If called from NetStorm, we need stop if total time > 5 secs
    {
      if(total_time_taken > 5000)
      {
        printf("Total time taken to get rstat is more than 5 secs. Skipping %d servers\n", num_servers - host_id - 1);
        return 1;
      }
    }
    if(running_as_tool)
    {
      printf ("Took = %llu ms\n\n", stime);
      show_rstat(&server_stats[host_id]);
    }
    server_stats_local_ptr++;
  }
  return 0;
}


// Following code is to be used when build tool

#ifdef RSTAT_TEST

void usage(char *cmd)
{
   printf("Invalid arguments\n");
   printf("Usage: %s Interval Timeout Server1 [Server2, Server3 .... Serer10]\n", cmd);
   printf("  Interval and Timeout are in milli-seconds\n");
   printf("  At least one server must be specified (max of 10)\n");
   exit(1);
}


int main(int argc, char *argv[])
{
Server_stats_gp server_stats[25];

  if (argc < 4 || argc > 13)
    usage(argv[0]);

  kw_set_time_stamp_mode ("2"); //arg is hardcoaded as we wil use gettimeofay
  init_ms_stamp();
  num_servers = argc - 3;
  running_as_tool = 1;

  // Get interval and Time out in milliseconds
  interval = atoi (argv[1]);
  time_out = atoi (argv[2]);

  // Doing Initialization of the array and RPC
  init_rstat(num_servers, &argv[3]);

  // Get data from structure.

  for(;;)
  {
    sleep(interval/1000);
    get_rstat_data_for_all_servers(num_servers, &server_stats[0]);
  }

  close_rstat();
}

#endif
