#!/bin/sh
#
# Name: nsu_start_test
# Author: Neeraj Jain
# Purpsose: To start netstorm from GUI/CLI/Scehduler/test_script 
#

# if INVOKER is "cli" then data will not send to GUI server.

# Exit Values: 
#  0 - Start Sucessful
#  -1 - Usage Error
#  -2 - Scenario File does not exits
#  -3 - Already Running
#  -1 - Start failed
# Modification History:
#   11/23/04: Neeraj - Initial Version
#   02/26/05:Neeraj:1.2.1 - Changed name, added lock and check, added -p
#     option and -d option
#   07/19/05:Neeraj:1.2.4 - Changed to take scen file with full path
#   02/27/06:Neeraj:1.5 - config.ini it to be taken from config folder
#   07/17/12:Prachi:1.34 - Support for one more type of INVOKER i.e. test_script 
#   11/27/17:Abhay: Added "-u" option for gui user
#
# Notes: Controller GUI assumes TestRun number will be in the 2nd line
# 

export LANG=en_us
export LD_LIBRARY_PATH=`echo $NS_WDIR/thirdparty/lib/mqm/lib64:$NS_WDIR/thirdparty/lib`
HOME_DIR=/home/cavisson
#Added for libefence lib
#If not set libefence was showing error in regular expression API
export EF_ALLOW_MALLOC_0=1
Lockfd=0
#************************************************************************************************
#default workspace
DW="admin"
#default profile
DP="default"
WORKSPACE=""
PROFILE=""
#WORK_PROFILE ==> WORKSPACE + PROFILE
WORK_PROFILE=""
NS_TA_DIR=""
NS_RTA_DIR="workspace"
PROJ_SUBPROJ=""

#check for workspace/profile name and RetlativeTestAsset Dir
check_and_set_workspace_profile()
{
  #if empty aregument passed
  if [ \( "X${1}" == "X" \) -o \( "X${1}" == "${DW}/${DP}" \) ];then
   WORKSPACE=$DW
   PROFILE=$DP
   WORK_PROFILE=${DW}/${DP}
   return 1
  fi

  #if default workspace/profile
   
  WORKSPACE=`echo $1 | egrep "/" | cut -d'/' -f1`
  PROFILE=`echo $1 | egrep "/" | cut -d'/' -f2`

  #<workspace> i.e. profile no given
  #<workspace>/ i.e. profile no given
  #/<profile> i.e. profile no given
  if [ "X$WORKSPACE" == "X" ];then
     #set default value
     WORKSPACE=$DW
  fi

  if [ "X$PROFILE" == "X" ];then
    #set default value
     PROFILE=$DP
  fi
  #if WORKSPACE is NOT default workspace
  if [ $WORKSPACE != $DW ];then
     #check if workspace exists
     if [ ! -d ${NS_WDIR}/${NS_RTA_DIR}/$WORKSPACE ];then
       #set to default workspace
       WORKSPACE=$DW
     fi
  fi
  #check if profile exists
  if [ ! -d ${NS_WDIR}/${NS_RTA_DIR}/$WORKSPACE/$PROFILE ];then
      #set to default workspace
      PROFILE=$DP
  fi

  #set workspace and profile path
  WORK_PROFILE=${WORKSPACE}/${PROFILE}
}

#det relative test assets dir
set_rta_dir()
{
  NS_RTA_DIR="workspace/$1/$2/cavisson"
}
#***********
ns_release_lock()
{
  #Release lock only if it is acquired earlier
  if [ $Lockfd != 0 ];then
    flock -u $Lockfd
    eval "exec $Lockfd<&-"
    Lockfd=0
  fi
}

ns_exit()
{
  #Release the lock in case it is acquired 
  ns_release_lock
  exit $1
}

var=`ulimit -n`
if [ $var -lt 262144 ];then
  echo "ERROR: System's max open files limit (ulimit -n) is: $var, it should be 262144"
  echo "Please set it to 262144 and try again."
  ns_exit 1
fi

#check the network interface status up or down  address status
ifstatus()
{
  ifconfig $1|grep -w RUNNING >/dev/null 2>&1
  if [ $? -eq 0 ]; then
    IF_STATUS=1;
  else
    IF_STATUS=0;
  fi
}

#BugID: 21809, Following code check the environment file is exists or not with their path on machine
check_environment_path()
{
  ENVIRONMENT_FILE="/etc/environment"

  if [ ! -f $ENVIRONMENT_FILE ];then
    echo "Error: Environment file [$ENVIRONMENT_FILE] does not exist."
    ns_exit -1
  fi
  ENV_PATH=`cat "$ENVIRONMENT_FILE" |grep -v '^#' |grep -v ^$ | sed -e 's/^[ \t]*//'|grep ^PATH`
  if [ $? -ne 0 ];then
    echo "Error: PATH is not set in [$ENVIRONMENT_FILE]."
    ns_exit -1
  fi
}

check_environment_path

# Following code is done to check the status of loopback interface, as it must be running to start the test. BugID:#18864 
IF_STATUS=0
ifstatus lo

if [ "$IF_STATUS" = "0" ]; then
  echo "Test can not be started as loopback interface is down.	kindly start it and try to run the test again"
  ns_exit -1
fi

gawk -V >/dev/null 2>&1
if [ $? != 0 ];then
  echo "package gawk is not installed and no information is available. Please install package gawk and restart test"
  ns_exit 1
fi

#Check if user is a registered 'Active' cavisson user
USER_NAME=`whoami 2>/dev/null`
if [ $? != 0 ];then
  echo "Error: Unable to get the real user name"
  ns_exit 1
fi

if [ "XX$USER_NAME" != "XXcavisson" ]; then
   echo "Error: User $USER_NAME is not allowed to run the test. Kindly run the test with cavisson user"
   ns_exit 1
fi

DEBUG=0
NETSTORM_BIN="bin/netstorm"
GUI_MAX_TEST_COUNT=0
gui_test_count=0

if [ "XX" = "XX$NS_WDIR" ]
then
  NS_WDIR=/home/cavisson/work
fi

get_gui_arguments()
{
  if [ "XX$INVOKER" == "XXcli" ];then 
    GUI_ARGS=""
  elif [ "XX$INVOKER" == "XXtest_script" -o "XX$INVOKER" == "XXdebug" ];then
    GUI_ARGS="-s 0.0.0.0"
  else
    GUIPort=`grep ^portNetstorm $GUIConfFile | awk -F= '{print $2}' | sed 's/ *//'`
    GUIPortcount=`echo $GUIPort | awk -F ' ' '{print NF}'`
    if [ $GUIPortcount -ne 1 ];then
      echo "Failed to start test: netstorm port is not configured correctly in webapps/sys/config.ini file"
      exit 1
    fi
    GUIIPAddress="127.0.0.1"
    GUI_ARGS="-s $GUIIPAddress:$GUIPort"
    NUM_TR_KEYWORD=`cat "$GUIConfFile" | grep -w "^[[:blank:]]*netstorm.execution.maxRunningTestRun" |wc -l`
    if [ $NUM_TR_KEYWORD -gt 1 ];then
      echo "Failed to start test: Keyword 'netstorm.execution.maxRunningTestRun' has duplicate entries in 'webapps/sys/config.ini'"
      exit 1
    fi
    NUM_TR_KEYWORD=`cat "$GUIConfFile" | grep -w "^[[:blank:]]*netstorm.execution.maxRunningTestRun"`
    GUI_MAX_TEST_COUNT=`echo $NUM_TR_KEYWORD | cut -d'=' -f 2 | tr -d '[:space:]'`
    if [ "x$GUI_MAX_TEST_COUNT" = "x" ];then
      GUI_MAX_TEST_COUNT=0
    fi
    if [ $GUI_MAX_TEST_COUNT -eq 0 ];then
      GUI_MAX_TEST_COUNT=2
    fi   
  fi
}

ns_get_lock()
{
  ctrl_name=`basename $NS_WDIR`
  mkdir -p $HOME_DIR/.tmp/
  Lockfile=$HOME_DIR/.tmp/.nsstartlock_${ctrl_name}
  Lockfd=`echo $GUIPort|tr -d '\r'`
  if [ ! -e "$Lockfile" ] ; then 
      touch "$Lockfile" 
  fi
  eval "exec $Lockfd<$Lockfile"
  
  retry_lock_time=10

  #Atleast wait for 10 second in case lock is not avaiable
  if [ $Wait_time -eq 0 ];then
    retry_count=3
  else
    retry_count=($Wait_time*6); 
  fi

  for((i=0;i<$retry_count;i++))
  {
    flock -eon $Lockfd || { sleep 10;continue; }
    echo $$ > $Lockfile;
    return 0;
  }
  lock_time=`stat --format "%Y" $Lockfile`
  curr_time=`date +%s`
  diff_time=`expr $curr_time - $lock_time`;
  if [ $diff_time -gt 300 ];then
    tpid=`cat $Lockfile`
    ps --pid $tpid|grep -w nsu_start_test >/dev/null
    if [ $? == 0 ];then
      kill -9 $tpid 2>/dev/null
      sleep 10
    fi 
    rm -rf $Lockfile
    ns_get_lock 
    return 0;
  fi 
  msgout "Failed to get lock on nsu_start_test, please try after 5 mins";
  ns_exit -1;
}


# This function check that whether previous tests are running in online mode or in offline mode
ns_wait_kill_func()
{
  retry_time=60
  GUI_TR_NUM=0

  while [ true ]
  do
    TR_NUM=1
    TR_NUM_LIST=`$NS_WDIR/bin/nsu_show_netstorm | awk '{print $1}' |  grep -v "TestRun" 2> /dev/null`
    # NO Test Running
    if [ ${#TR_NUM_LIST} -eq 0 ] ;then 
      return 0
    fi
    GUI_TR_NUM=0
    for TR_NUM in $TR_NUM_LIST
    do
      #check for gui
      Global_dat=$NS_WDIR/logs/TR$TR_NUM/global.dat
      #if global.dat file contains GUI_SERVER value NONE i.e. test is running in offline mode
      if [ -f $Global_dat ] ;then
        Test_mode=`cat $Global_dat|grep GUI_SERVER|cut -d' ' -f 2`
        if [ "XX$Test_mode" != "XXNONE" ]; then
          if [ $GUI_TR_NUM -eq 0 ]; then
	    GUI_TR_NUM=$TR_NUM
          fi
          gui_test_count=`expr $gui_test_count + 1`
        fi
      fi
      if [ "$ROLE" == "admin" ];then
        CON_MON_TEST_RUN=`cat $NS_WDIR/webapps/sys/config.ini | grep -v '#' |awk -F= '/nde.testRunNum/{print $2}' | tr -d ' '` 2> /dev/null
        if [ "$TR_NUM" ==  "$CON_MON_TEST_RUN" ];then
          ROLE=normal
        fi
      fi
    done  

    # Run Test runs until gui_test_count not equals to GUI_MAX_TEST_COUNT present in config.ini
    if [ $gui_test_count -lt $GUI_MAX_TEST_COUNT ] ;then 
      return 0
    fi
    if [ $Wait_time -eq 0 ];then
     break;
    fi
    sleep $retry_time;
    Wait_time=`expr $Wait_time - 1`;
   done
  
  if [ $Wait_action -eq 0 ]; then
    if [ $GUI_MAX_TEST_COUNT -eq 1 ];then
      echo "Controller is in use so cannot start new test."
    else
      echo "All $GUI_MAX_TEST_COUNT controllers are in use so cannot start new test."
    fi

    echo "You can try again after running test is over. Alternatively you can schedule your test using [Scenario Schedule]"
    ns_exit 10
  elif [ $Wait_action -eq 1 ];then
    echo "Stop Test TR$GUI_TR_NUM fourcefully "
    nsu_stop_test -f $GUI_TR_NUM -C "nsu_start_test"
    sleep 10
  elif [ $Wait_action -eq 2 ];then
    echo "Warning: $gui_test_count Tests is already running in online mode, starting new test will affect the test data"
    echo "Starting test in offline mode"
    GUI_ARGS="-s 0.0.0.0"
  fi
  return 0
}

checking_for_script_debug_option()
{
  scriptDebugMode=`echo ${INVOKER}|grep '^debug'|wc -w`
  if [ $scriptDebugMode = 1 ];then
    scriptDebugOption=`echo ${INVOKER}|grep '^debug,'|wc -w`
    if [ $scriptDebugOption = 0 ];then
      if [ "XX${INVOKER}" = "XXdebug" ];then
        conn_timeout=300
        read_timeout=3600
      fi	 
    else
      num_field=`echo ${INVOKER}|tr , " "| wc -w`
      if [ $num_field = 3 ];then
        conn_timeout_str=`echo ${INVOKER} | cut -d',' -f2`
        conn_timeout=`echo ${conn_timeout_str} | grep -E ^\-?[0-9]+$`
        read_timeout_str=`echo ${INVOKER} | cut -d',' -f3`
        read_timeout=`echo ${read_timeout_str} | grep -E ^\-?[0-9]+$`

        scriptDebugOption=`echo ${INVOKER}|grep "^debug,$conn_timeout_str,$read_timeout_str," |wc -w`
        if [ $scriptDebugOption = 0 -a "X$read_timeout" != "X" -a "X$conn_timeout" != "X" ];then
          INVOKER=debug
        fi
      elif [ $num_field = 2 ];then
        conn_timeout_str=`echo ${INVOKER} | cut -d',' -f2`
        conn_timeout=`echo ${conn_timeout_str} | grep -E ^\-?[0-9]+$`

        scriptDebugOption=`echo ${INVOKER}|grep "^debug,$conn_timeout_str," |wc -w`
        if [ $scriptDebugOption = 0 -a "X$conn_timeout" != "X" ];then
          INVOKER=debug
          read_timeout=3600
        fi
      fi
    fi
  fi
}

display_help_and_ns_exit()
{
  echo "ERROR: Incorrect usage"
  echo "Usage:"
  echo "nsu_start_test -n <Scenario Name> [-S gui|cli|scheduler|test_script|guiFg|debug] [-l] [-N Test Name] [-R retry count] [-I retry interval in sec] [-T timeout is sec] [-p Profile Name] [-C <additional keywords>]"
  echo "Where:"
  echo "  -n is a mandatory option. It is used to specify scenario name that would be Project/Subproject/<ScenarioName>."
  echo "     If 'Project/Subproject/' not given then <ScenarioName> assume from 'default/default/'"
  echo "     <Scenario Name> can be with or without .conf extension."

  echo "  -S is used to specify who invoked this command. Default is cli."
  echo "     cli is used when command is invoked using CLI"
  echo "     guiFg is used when command is invoked from Test suite and data is to be send to GUI"
  echo "     gui is used when command is invoked from GUI."
  echo "     scheduler is used when command is invoked from scheduler."
  echo "     debug|[connection_timeout]|[read_timeout] is used when command is invoked for debugging the netstorm script."
  echo "     test_script is used when command is invoked from test script from script GUI."
  echo "     In case of cli and guiFg, test is started in foreground and progress report is shown on the console."
  echo "     In other cases, test is started in background."

  echo "  -l is used to start test in master mode. Default is non master mode."
  echo "  -u is used for gui user who is logged in." 
  echo "  -N is used to provide test name for this test. It should be in double quotes."
  echo "     If -N is not used, then test name is taken from scenario file."
  echo "  -R is used to specify retry count for pre test checks. Default is no retry."
  echo "  -I is used to specify retry interval in seconds for pre test checks. Default is 60 seconds."
  echo "  -T is used to specify timeout in seconds for pre test checks. Default is 15 seconds."
  echo "  -w is used to specify wait time(in minutes) till new test wait for the action performed for the previously online running test."
  echo "  -f action performed after wait time expires, it has 3 modes."
           echo " Mode 0 is used to specify, don't start a new test."
           echo " Mode 1 is used to specify, forcefully stop previously started test and start a new test after wait time."
           echo " Mode 2 is used to specify, start a new test in offline mode"
  echo "  Options -w and -f are valid only for test is invoked from scheduler or from GUI."
  echo "  Options -R, -I and -T are valid only for test is invoked from scheduler and scenario is using Pre test checks."
  echo "  -W is used to specify the <workspace>/<profile>. Defult Workspace and Profile will be used, if not specified."
  echo "  -C is used to specify additional keywords to be added in scenario at runtime."
  ns_exit 1
}

echo "XXX $@ XXX" | grep "\-n" 2>/dev/null 1>&2
if [ $? != 0 ]; then
    display_help_and_ns_exit
fi

SCENARIO=""
INVOKER="cli"
Master_arg=""
TEST_NAME="NA"
PRE_TEST_CHECK_RETRY_COUNT=0
PRE_TEST_CHECK_RETRY_INTERVAL=60
PRE_TEST_CHECK_TIMEOUT=15
Controller_arg=""
Generator_arg=""
Wait_action=0
Wait_time=0
Lockfile=""
ROLE=""
ADDITIONAL_KW="NA"
TRACE_LOG_FILE="$NS_WDIR/webapps/netstorm/temp/nsu_start_test.log.$$"
TEST_INIT_STATUS_FLAG=0
# NetCloud: Added new option to verify machine type,
# -t <controller> or <generator>, here generator is default.
# To initate test on external controller, we need to extract external controller 
# tar which consist of scenarios and scripts. Now GUI will send -t option with 
# value controller in case of external controller.
Machine_type="generator"
TEST_ASSET=0

while getopts m:n:S:N:R:I:T:t:Dw:f:u:r:j:W:FC:? c
do
    case $c in
        n) SCENARIO="$OPTARG" ;;
        S) INVOKER="$OPTARG";;
        u) TEST_USER="$OPTARG";;
        m) Generator_arg="-m $OPTARG";;
        N) TEST_NAME="$OPTARG" ;;
        D) DEBUG="1" ;;
        R) if [ $INVOKER != "scheduler" ]; then
             echo "<retry count>, <retry interval> and <timeout> only valid if Pre test check is running from scheduler"
             ns_exit -1
           else
             PRE_TEST_CHECK_RETRY_COUNT="$OPTARG" 
           fi
           ;;
        I) if [ $INVOKER != "scheduler" ]; then
             echo "<retry count>, <retry interval> and <timeout> only valid if Pre test check is running from scheduler"
             ns_exit -1
           else
             PRE_TEST_CHECK_RETRY_INTERVAL="$OPTARG" 
             if [ "$PRE_TEST_CHECK_RETRY_INTERVAL" -le 0 ]; then
               echo "Retry Interval should be greater than 0"
               ns_exit 1
             fi
           fi
           ;;
        T) if [ $INVOKER != "scheduler" ]; then
             echo "<retry count>, <retry interval> and <timeout> only valid if Pre test check is running from scheduler"
             ns_exit 1
           else
             PRE_TEST_CHECK_TIMEOUT="$OPTARG" 
             if [ "$PRE_TEST_CHECK_TIMEOUT" -le 0 ]; then
               echo "Timeout should be greater than 0"
               ns_exit 1
             fi
           fi
           ;;
        t) Machine_type="$OPTARG" ;;
        w) Wait_time="$OPTARG"
           if [ $Wait_time -lt 0 ];then
             echo "Error: Wait time should be positive integer"
             ns_exit -1
           fi
           ;;
        f) Wait_action="$OPTARG" 
           if [ $Wait_action -ne 0 -a $Wait_action -ne 1 -a $Wait_action -ne 2 ];then
             echo "Error: Invalid mode for option -f"
             ns_exit -1
           fi
           ;;
        j) TEST_ASSET="$OPTARG"
           if [ $TEST_ASSET -ne 0 -a $TEST_ASSET -ne 1 ];then
             echo "Error: Invalid value for option -j"
             ns_exit -1
           fi
           ;; 
        r) ROLE="$OPTARG";; 
        F) TEST_INIT_STATUS_FLAG=1;;
	W) WORK_PROFILE="$OPTARG" ;;
	C) ADDITIONAL_KW="$OPTARG";;
        ?) display_help_and_ns_exit ;;
    esac
done

#Checking for script debug option
checking_for_script_debug_option

#Bug 39668
if [ $INVOKER != "cli" -a $INVOKER != "scheduler" -a $INVOKER != "gui" -a $INVOKER != "guiFg" -a $INVOKER != "test_script" -a $INVOKER != "debug" ]; then
  echo "Invalid Invoker name \"$INVOKER\""
  display_help_and_ns_exit
fi

if [ "XX$TEST_USER" == "XX"  -a "XX$ROLE" == "XX" ];then
  TEST_USER=$USER_NAME
  ROLE="normal"
elif [ "XX$TEST_USER" == "XX"  -o "XX$ROLE" == "XX" ];then
  echo "Role(-r) should be provided with User(-u) option"
  ns_exit -1
elif [ "XX$ROLE" == "XXguest" ];then
  echo "user $TEST_USER is not allowed to run the test"
  ns_exit -1
fi
 
# In NetCloud setup we need to set generator machines with path provided by controller, therefore earlier we
# were trying to set PATH variable here.
# But in ubuntu machines when logging as sudo or su it reset PATH variable with default path, hence this path
# provided by controller was overridden by default path.
# 
# In release 3.9.6, for Generator
# In order to fix above issue save generator path in local variable (in shell script nii_start_test) and export PATH variable 
# with this local variable 
if [ "XX$Generator_arg" != "XX" ];then
  export PATH=$GEN_PATH
fi

trace_log()
{
  echo "`date +"%F %X"`|$TEST_USER|$1" >>$TRACE_LOG_FILE
}

debug_log()
{
  if [ "$DEBUG" == "0" ];then
    return
  fi
  echo $*
}

msgout ()
{
    #Creating scheduler log file with USERNAME since any user can run with scheduler
    outfile=$NS_WDIR/logs/scheduler/$USER_NAME.scheduler.log
    if [ "XX${INVOKER}XX" == "XXschedulerXX" ]; then
        touch $outfile
        if [ `ls -l $outfile | awk '{print $5}'` -gt 1048576 ]; then
            mv -f $outfile ${outfile}.prev
        fi
        echo -n "[`date +%r`] " >> $outfile
        echo -e "$@" >> $outfile
    fi
        echo -e "$@"
}

stop_running_tr()
{
  debug_log "Going to stop tr if started...\c"
  TR_LIST=`nsu_show_netstorm |cut -d' ' -f1 |grep -v TestRun 2>/dev/null`
  if [ ${#TR_LIST} -eq 0 ];then
    debug_log "TR $TestRunNum was not running"
    return
  else
    for testid in $TR_LIST
    do
      if [ "$testid" == "$TestRunNum" ];then
        nsu_stop_test -f $testid -C "nsu_start_test"
        debug_log "TR $TestRunNum stopped" 
        trace_log "cleaning on error, stopping TR $TestRunNum"
      fi
    done
  fi
}

clean_on_error()
{
  msgout "Error in starting scenario...\n"
  cat $NetstormLogFile
  stop_running_tr
}

#Function used to extract external controller data(scenario, scripts and external generator data)
extract_controller_data()
{
  if [ "$Machine_type" == "controller" ]; then
    tar hxzC $NS_WDIR/.tmp/.controller/ -f $NS_WDIR/.tmp/.controller/external_controller.tar.gz
    tar hxzC $NS_TA_DIR/$PROJ_SUBPROJ/scenarios/ -f $NS_WDIR/.tmp/.controller/external_scenario.tar.gz
    tar hxzC $NS_TA_DIR/$PROJ_SUBPROJ/scripts/ -f $NS_WDIR/.tmp/.controller/scripts.tar.gz
  fi
}

get_netstorm_pid()
{
  # Get self pid
  NSU_START_TEST_PID=$$
  if [ "XX$INVOKER" == "XXdebug" ] ; then
    NSU_START_TEST_PID=`ps --no-headers --ppid $NSU_START_TEST_PID -o 'pid args' | grep cavdebug | awk '{print $1}'`
    i=1
    while [ $i != 10 ]
    do
      NSU_START_TEST_PID_GDB=`ps --no-headers --ppid $NSU_START_TEST_PID -o 'pid args' | grep gdb | awk '{print $1}'`
      if [ "XX$NSU_START_TEST_PID_GDB" == "XX" ];then
        debug_log "NSU_START_TEST_PID_GDB=$NSU_START_TEST_PID_GDB - No pid found, sleeping for $i second"
        sleep 1
        let i=i+1
        continue 
      fi

      NSU_START_TEST_PID=$NSU_START_TEST_PID_GDB
      debug_log "NSU_START_TEST_PID_GDB is $NSU_START_TEST_PID_GDB"
      break
    done
  fi

  debug_log "NSU_START_TEST_PID = $NSU_START_TEST_PID"

  # Find nestorm pid as child of self pid
  #Allow some time for netstorm process to start
  i=1
  while [ $i != 10 ]
  do
    NETSTORM_PID=""
    # Since this will return two child (netstorm and ps command itself)
    # we need to grep using scenario file name 
    NETSTORM_PID=`ps --no-headers --ppid $NSU_START_TEST_PID -o 'pid args' | grep  $ScenFileName | awk '{print $1}'`
    #echo "The Status of the command is $?"
    #echo "NETSTORM_PID = {$NETSTORM_PID}"

    #Sometimes the above command status is 0 but the NETSTORM_PID is NULL 
    #so sleep is introduced if NETSTORM_PID is NULL
    if [ "XX$NETSTORM_PID" == "XX" ];then
      debug_log "get_netstorm_pid - No pid found, sleeping for $i second"
      sleep 1
      let i=i+1
      continue 
    fi

    debug_log "NETSTORM_PID is $NETSTORM_PID "
    break
  done

  if [ "XX$NETSTORM_PID" == "XX" ]
  then
    #BUG : 21990 - Error message should be user friendly if the test is not able to start due to missing gawk package
    #MSG will be last line of file netstorm.netstorm.log 
    MSG=`tail -1 $NetstormLogFile`
    msgout "$MSG"
    msgout "Error in getting the netstorm pid"
    trace_log "Error $MSG"
    ns_exit -1
  fi
}

# move netstorm.log to Testrun dir with name TestRunOutput.log
move_log_file_to_test_dir()
{
  TestRunOutputFile=$NS_WDIR/logs/TR$TestRunNum/TestRunOutput.log
  if [ -f $NS_WDIR/logs/TR$TestRunNum/runtime_changes/runtime_changes_all.conf ];then
    mv $NS_WDIR/logs/TR$TestRunNum/runtime_changes/runtime_changes_all.conf $NS_WDIR/logs/TR$TestRunNum/runtime_changes/runtime_changes_all.conf_`date +'%Y%m%d%H%M%S'`
  fi

  if [ -f $TestRunOutputFile ]; then
    mv $TestRunOutputFile ${TestRunOutputFile}.`date +'%Y%m%d%H%M%S'`
  fi
  
  mv -f $NetstormLogFile $TestRunOutputFile
  if [ $? != 0 ];then
    msgout "Error in moving $NetstormLogFile to $TestRunOutputFile"
  fi
  debug_log "$NetstormLogFile moved to $TestRunOutputFile"

  #Release the lock in case it is acquired 
  ns_release_lock
}

#************************************************************************************************
#************************************************************************************************

#************************************************************************************************
check_and_set_workspace_profile $WORK_PROFILE
set_rta_dir $WORKSPACE $PROFILE
#set aboslute test assets dir
NS_TA_DIR=$NS_WDIR/${NS_RTA_DIR}
export NS_RTA_DIR
#************************************************************************************************


ScenName=$SCENARIO
#After code chnages in RTG GUI for averaging at serer, we do not need much delay
Delay="-d 1"

FirstChar=`echo $ScenName | cut -c1`
if [ $FirstChar == "/" ];then
  SFileName=`echo $ScenName|awk -F "$NS_WDIR/" '{print $2}'`
  if [ -z $SFileName ];then
    msgout "Invalid scenario $ScenName"
    ns_exit -2
  fi
else
  NUM=`echo "$ScenName" | awk -F "/" '{print NF}'`
  if [ $NUM == 1 ];then
    PROJ_SUBPROJ="default/default"
    SFileName=$NS_TA_DIR/default/default/scenarios/$ScenName
  elif [ $NUM == 3 ];then
    sname=`basename $ScenName`
    dname=`dirname $ScenName`
    PROJ_SUBPROJ=$dname
    SFileName=$NS_TA_DIR/$dname/scenarios/$sname
  else
    echo "'Project/Subproject/<ScenarioName>' is not given in proper format."
    ns_exit -1
  fi
fi
 
# NetCloud Changes: Function called before setting scenario path and name in case of external controller
extract_controller_data

echo $SFileName | grep "\.conf$" >/dev/null

if [ $? -ne 0 ]; then
  ScenFileName=${SFileName}.conf
else
  ScenFileName=$SFileName
fi

if [ ! -f  $ScenFileName ]; then
  msgout "Scenario file not found, $ScenFileName"
  ns_exit -2
fi


  egrep -w "^NS_GENERATOR|^GEN_LOCATION" $ScenFileName >/dev/null
  if [ $? -eq 0 ];then
    #set controller argument.
    Controller_arg="-l"
    if [ "X$Generator_arg" != "X" ];then
      echo "Error : both the arguments(controller and generator)can not given together."
      ns_exit -1
    fi
    /etc/init.d/cmon status| grep "cmon is running" >/dev/null 2>&1
    if [ $? -ne 0 ];then
      msgout "CavErr[1060083]: Cmon is not running on controller. Please start cmon and try again."
      ns_exit -1
    fi
  fi
  
  netcloud_mode=`grep -w ^NETCLOUD_MODE $ScenFileName | cut -d" " -f2 `>/dev/null 2>&1
  if [ "XX$netcloud_mode" == "XX" ];then
    netcloud_mode=0
  fi
  if [ $netcloud_mode -eq 2 ];then
    if [ "X$Generator_arg" != "X" ];then
      echo "Error : both the arguments(controller and generator)can not given together."
      ns_exit -1
    fi
    #Controller is running in mode 2 then no need to create TAR files
    #We have already created tar in mode 2, we just need to ship those tars
    Controller_arg="$Controller_arg -x do_not_create_tar"
  fi

if [ "XX$Controller_arg" != "XX" ];then
  Master_arg=$Controller_arg
fi

if [ "XX$Generator_arg" != "XX" ];then
  Master_arg=$Generator_arg
fi


# Do not change this file name as it is used by netstorm for redirecting standard output JavaNVM, If change is must then also make changes
# in file ns_njvm.c in out_redirect_file 
NetstormLogFile=$NS_WDIR/webapps/netstorm/logs/$TEST_USER.netstorm.log
GUIConfFile=$NS_WDIR/webapps/sys/config.ini

get_gui_arguments

if [ "XX${INVOKER}XX" == "XXschedulerXX" ]; then
    msgout "Starting scheduled test $ScenFileName"
fi

cd $NS_WDIR
#bug 92660: gRPC: avoid locking in case of guiFg mode 
#if we are running test run through cmd line than need not to check netstorm is running or not.
if [ "XX$INVOKER" != "XXcli" -a "XX$INVOKER" != "XXtest_script" -a "XX$INVOKER" != "XXdebug" -a $INVOKER != "guiFg" ];then
  #Aquire lock before executing this part in case of Online Mode Request , wait in case failed to get lock
  ns_get_lock
  RUNNING_TEST=`$NS_WDIR/bin/nsu_show_netstorm | awk '{print $1}' |  grep -v "TestRun" 2> /dev/null`
  if [ $? == 0 ];then
    if [ "XX$INVOKER" == "XXgui" -o "XX$INVOKER" == "XXscheduler" ];then
      ns_wait_kill_func
    # This is the case where test is already running and again we are try to running a test with guiFg
    # In this case we will make GUI_ARGS empty and run the test in non gui mode 
    #elif [ "XX$INVOKER" == "XXguiFg" ]; then
    elif [ "XX$INVOKER" == "XXguiFg" ]; then
     GUI_ARGS="-s 0.0.0.0"
    else
      msgout "Following Test Run(s) are running:"
      msgout $RUNNING_TEST
      msgout "Please try later."
      #Release the lock in case it is acquired 
      ns_exit -3
    fi
  fi
fi


if [ "XX$INVOKER" = "XXdebug" ] ; then
  NETSTORM_BIN="bin/cavdebug $conn_timeout $read_timeout"
else
  #if debug is given with non zero value than it should run with netstorm.debug
  IS_DEBUG=`grep ^G_DEBUG $ScenFileName | awk '{ print $3}'`
  IS_DEBUG_TRACE=`grep ^DEBUG_TRACE $ScenFileName | awk '{ print $2}'`

  if [ "X$IS_DEBUG" != "X" -a "X$IS_DEBUG" != "X0" ] || [ "X$IS_DEBUG_TRACE" != "X" -a "X$IS_DEBUG_TRACE" != "X0" ] ; then
    NETSTORM_BIN="bin/netstorm.debug"
  fi
fi

#Extract TNAME from scenario and replace TEST_NAME if not available before. If TNAME not found in scenario then TEST_NAME would be replace with NA
if [ "$TEST_NAME" == "NA" ]; then
  TEST_NAME=`cat $ScenFileName | grep ^TNAME | sed 's/^TNAME //g'`
  if [ "$TEST_NAME" == "" ]; then
    TEST_NAME="NA"
  fi
else
  sed -i '/^TNAME/d' $ScenFileName
  echo "TNAME $TEST_NAME" >>$ScenFileName
fi


# Note - DO NOT USE eval as it create another child process of nsu_start_test
#        which cause issues in get_netstorm_pid() function

INSTANCE=ns_inst`date +%s%3N`
PRE_TEST_CHECK_ARGS=""
if [ "XX$PRE_TEST_CHECK_RETRY_COUNT" != "XX0" ]; then
  PRE_TEST_CHECK_ARGS="-R $PRE_TEST_CHECK_RETRY_COUNT -I ${PRE_TEST_CHECK_RETRY_INTERVAL} -T ${PRE_TEST_CHECK_TIMEOUT}"
fi

if [ "XX$INVOKER" != "XXcli" -a "XX$INVOKER" != "XXtest_script" -a "XX$INVOKER" != "XXdebug" -a "XX$TEST_INIT_STATUS_FLAG" == "XX1" ];then
  GUI_ARGS="$GUI_ARGS -F"
fi

if [ "XX$INVOKER" = "XXdebug" ]; then
  NS_ARGS="-c $ScenFileName $Delay $GUI_ARGS $Master_arg ${PRE_TEST_CHECK_ARGS} -u $TEST_USER -r $ROLE -D 1 -j $TEST_ASSET -i $INSTANCE"
else
  NS_ARGS="-c $ScenFileName $Delay $GUI_ARGS $Master_arg ${PRE_TEST_CHECK_ARGS} -u $TEST_USER -r $ROLE -j $TEST_ASSET -i $INSTANCE" 
fi

#If running from cli, start test in fore ground so that progress report comes on console.
# Also do not send data to GUI server.

NSU_START_TEST_PID=$$
NSU_START_TEST_PPID=`ps --no-headers --pid $NSU_START_TEST_PID -o 'ppid'`
TERMINAL_PID=`ps | grep bash|grep $NSU_START_TEST_PPID`
if [ "XX$TERMINAL_PID" != "XX" ]; then
  nsu_two_step_auth
  if [ $? != 0 ];then
    echo  "Second level authenticate failed"
    ns_exit $?
  fi
fi

if [ "XX$INVOKER" == "XXguiFg" -o "XX$INVOKER" == "XXcli" ]; then
  debug_log "Starting test in forground using - $NETSTORM_BIN $NS_ARGS -N "\"${TEST_NAME}\"""
  $NETSTORM_BIN $NS_ARGS -N "${TEST_NAME}" -C "${ADDITIONAL_KW}"
  #bug 92660: cavisson lite: emitt succees of error message
  if [ $? != 0 ];then
    echo -n "_CM_STATUS_ERROR_"
  else
    echo -n "_CM_STATUS_SUCCESS_"
  fi
  #echo -n $?
  ns_exit $?
fi

#Remove this file so that we do not move old file which is
# is not for this test run to TR Dir
[ -f $NetstormLogFile ] && mv  -f $NetstormLogFile $NetstormLogFile.last
touch $NetstormLogFile

# Here we come when we need to run in background
debug_log "Starting netstorm in background using - nohup $NETSTORM_BIN $NS_ARGS -N "\"${TEST_NAME}\"""
nohup $NETSTORM_BIN $NS_ARGS -N "${TEST_NAME}" -C "${ADDITIONAL_KW}" 2>&1 | awk '{print strftime("%m/%d/%y %H:%M:%S|") $0; fflush()}' >> $NetstormLogFile 2>&1 &

#Get Netstorm pid
get_netstorm_pid
INST_DIR=$NS_WDIR/.tmp/${INSTANCE}_${NETSTORM_PID}

#Sleep for 5 seconds then check for test run
#if test run is not started then exit
# As processing may take time more than 5 seconds, so chaeck it in a loop of 5 seconds 
TestRunNum=""
while [ true ]
do  
# When test fail, nsu_start_test come out after long time 
# Here we were using sleep of 5 sec and then verify test status using nsu_show_netstorm 
# For early detection of testrun status, we will simply check for parent processs using pid command. 
# If it is not running, then give an error and terminate, else sleep for 5 sec and next call nsu_show_netstorm
  debug_log "NetStorm parent process id is $NETSTORM_PID"
# In release 3.9.2, Early detection of test run status, here test can have duration less than 5 sec. 
# Hence we need not to sleep for other 5 seconds.
  kill -0 $NETSTORM_PID >/dev/null 2>&1
  if [ $? -ne 0 ];then
    clean_on_error
    ns_exit -1 
  elif [ -d "$INST_DIR" ];then
    TestRunNum=`sed -n '1p' $INST_DIR/keys`
    if [ "XX$INVOKER" == "XXdebug" -a "X$TestRunNum" != "X" ] ; then
      break
    fi
    [ "X`sed -n '2p' $INST_DIR/keys`" == "X1" ] && move_log_file_to_test_dir && break
  fi

  sleep 3
done 

#Support of Keyword YAML_PATH

yaml_file_name=`grep -w ^YAML_PATH $ScenFileName | cut -d" " -f2 | awk -F'/' '{print $3"/"$4}'`>/dev/null 2>&1
if [ "XX$yaml_file_name" != "XX" -a "XX$yaml_file_name" != "NA" ];then
  yaml_file_src_path="$NS_TA_DIR/$PROJ_SUBPROJ/scenarios/$yaml_file_name"
  yaml_file_dest_path="$NS_WDIR/logs/TR$TestRunNum/scenario.yaml"

  if [ -f $yaml_file_src_path ]; then
    trace_log "Coping $yaml_file_src_path to $yaml_file_dest_path"
    cp $yaml_file_src_path $yaml_file_dest_path
  else
    trace_log "YAML file '$yaml_file_src_path' does not exist."
  fi
fi

# Controller GUI assumes TestRun number will be in the 2nd line
msgout "Netstorm started successfully. TestRunNumber is"
msgout "$TestRunNum"
trace_log "Test started with id $TestRunNum"
ns_exit 0
