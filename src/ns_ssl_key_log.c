/***************************************************************
This file is added to capture the ssl keys so that any encrypted
tcpdump captured can be decoded in wireshark for analysis if 
required. To save the key in file SSL_KEY_LOG keyward should be
enabled.Following is the syntex of SSL_KEY_LOG.
SSL_KEY_LOG <0/1> <File_Name>
0 : Disable
1 : Enable
File_Name : File where stored keys will be stored.
In case SSL_KEY_LOG is enabled and filename is not provided than 
keys will be stored in default file ("/tmp/cav_ssl_key_log.txt")
Steps to use the key file to decode the https packets in wireshark.  
1. Enable the SSL_KEY_LOG 
2. Capture the https packets using tcpdump
3. Load key file in wrireshark using edit preferences for 
   ssl protocol (pre) master key 
3. Open captured tcpdump in wireshark 
****************************************************************/
#define PREFIX      "CLIENT_RANDOM "
#define PREFIX_LEN  (sizeof(PREFIX) - 1)
#define FIRSTLINE   "# SSL key logfile generated by Netstorm\n"
#define FIRSTLINE_LEN (sizeof(FIRSTLINE) - 1)

#include <openssl/bio.h>

static void init_key_log_file(void)
{
  NSDL3_SSL(NULL, NULL, "Method called");
  global_settings->ssl_key_log_fd = open(global_settings->ssl_key_log_file, O_WRONLY | O_APPEND | O_CREAT | O_CLOEXEC, 0644);
  if (global_settings->ssl_key_log_fd < 0)
  {
    fprintf(stderr,"Failed to open SSL_KEY_LOG file %s. Hence disabling SSL_KEY_LOG\n",global_settings->ssl_key_log_file);
    global_settings->ssl_key_log = 0;
    return ;
  }
  if(lseek(global_settings->ssl_key_log_fd, 0, SEEK_END) == 0) 
  {
    /* file is opened successfully and there is no data (pos == 0) */
    write(global_settings->ssl_key_log_fd, FIRSTLINE, FIRSTLINE_LEN);
  }
}

void kw_set_ssl_key_log(char *buf)
{
  
  NSDL3_SSL(NULL, NULL, "Method called");
  char keyword[1024];

  sscanf(buf, "%s %d %s", keyword, &global_settings->ssl_key_log, global_settings->ssl_key_log_file);
  if(global_settings->ssl_key_log < 0 || global_settings->ssl_key_log > 1)
  {
    fprintf(stderr,"SSL_KEY_LOG can have values 0 or 1 to enable or disable the ssl key logging. Setting to default(0)\n");
    global_settings->ssl_key_log = 0;
    return ;
  }

  if(global_settings->ssl_key_log)
  {
    NSDL3_SSL(NULL, NULL, "ssl_key_log");
    if(global_settings->ssl_key_log_file[0] == '\0')
    {
      fprintf(stderr,"SSL_KEY_LOG filename not provided.Setting to default(/tmp/cav_ssl_key_log.txt)\n");
      strcpy(global_settings->ssl_key_log_file,"/tmp/cav_ssl_key_log.txt");
    }
    init_key_log_file();
  }
}

static inline void put_hex(char *buffer, int pos, char c)
{
  unsigned char c1 = ((unsigned char) c) >> 4;
  unsigned char c2 = c & 0xF;
  buffer[pos] = c1 < 10 ? '0' + c1 : 'A' + c1 - 10;
  buffer[pos+1] = c2 < 10 ? '0' + c2 : 'A' + c2 - 10;
}

#if OPENSSL_VERSION_NUMBER < 0x10100000L
static void write_to_fd(int fd, unsigned char *client_random,unsigned char *master_key, int master_key_length)
{

  int pos, i;
  char line[PREFIX_LEN + 2 * SSL3_RANDOM_SIZE + 1 + 2 * SSL_MAX_MASTER_KEY_LENGTH + 1];

  memcpy(line, PREFIX, PREFIX_LEN);
  pos = PREFIX_LEN;
  /* Client Random for SSLv3/TLS */
  for (i = 0; i < SSL3_RANDOM_SIZE; i++) {
    put_hex(line, pos, client_random[i]);
    pos += 2;
  }
  line[pos++] = ' ';
  /* Master Secret (size is at most SSL_MAX_MASTER_KEY_LENGTH) */
  for (i = 0; i < master_key_length; i++) {
    put_hex(line, pos, master_key[i]);
    pos += 2;
  }
  line[pos++] = '\n';
  /* Write at once rather than using buffered I/O. Perhaps there is concurrent
   * write access so do not write hex values one by one. */
  write(fd, line, pos);
}
#endif

#if OPENSSL_VERSION_NUMBER >= 0x10100000L
static BIO *bio_keylog = NULL;
static void keylog_callback(const SSL *ssl, const char *line)
{
    NSDL3_SSL(NULL, NULL, "Method called: ssl=%p, keylen=%d, secretkey=%s",ssl, strlen(line), line);
    if (bio_keylog == NULL) {
        fprintf(stderr, "Keylog callback is invoked without valid file!\n");
        return;
    }

    /*
     * There might be concurrent writers to the keylog file, so we must ensure
     * that the given line is written at once.
     */
    BIO_printf(bio_keylog, "%s\n", line);
    (void)BIO_flush(bio_keylog);
}
#endif


#if OPENSSL_VERSION_NUMBER >= 0x10100000L
int set_keylog_file(SSL_CTX *ctx, const char *keylog_file)
{
    NSDL3_SSL(NULL, NULL, "Method called, ctx=%p, keylog_file=%s",ctx, keylog_file);
    /* Close any open files */
    BIO_free_all(bio_keylog);
    bio_keylog = NULL;

    if (ctx == NULL || keylog_file == NULL) {
        /* Keylogging is disabled, OK. */
        return 0;
    }

    /*
     * Append rather than write in order to allow concurrent modification.
     * Furthermore, this preserves existing keylog files which is useful when
     * the tool is run multiple times.
     */
    bio_keylog = BIO_new_file(keylog_file, "a");
    if (bio_keylog == NULL) {
        fprintf(stderr, "Error writing keylog file %s\n", keylog_file);
        return 1;
    }

    /* Write a header for seekable, empty files (this excludes pipes). */
    if (BIO_tell(bio_keylog) == 0) {
        BIO_puts(bio_keylog,
                 "# SSL/TLS secrets log file, generated by OpenSSL\n");
        (void)BIO_flush(bio_keylog);
    }
    SSL_CTX_keylog_cb_func cb = SSL_CTX_get_keylog_callback(ctx);
    if(!cb) SSL_CTX_set_keylog_callback(ctx, keylog_callback);
    NSDL3_SSL(NULL, NULL, "after setting keylog_callback=%p", SSL_CTX_get_keylog_callback(ctx));
    return 0;
}
#endif

void inline ns_ssl_key_log(const SSL *ssl)
{
  NSDL3_SSL(NULL, NULL, "Method called");
  NSDL4_SSL(NULL, NULL, "ssl_key_log is enabled, OPENSSL_VERSION_NUMBER =0x%llxL", OPENSSL_VERSION_NUMBER);
  const SSL_SESSION *session = SSL_get_session(ssl);
  #if OPENSSL_VERSION_NUMBER < 0x10100000L
  unsigned char client_random[SSL3_RANDOM_SIZE];
  unsigned char master_key[SSL_MAX_MASTER_KEY_LENGTH];
  int master_key_length = 0;
  #endif
  if (session) 
  {
    NSDL4_SSL(NULL, NULL, "get master key, session=%p", session);
#if OPENSSL_VERSION_NUMBER >= 0x10100000L
    /* Bug#84169: Code under (#if OPENSSL_VERSION_NUMBER >= 0x10100000L) not required,so commented */
    /*SSL_CTX *ssl_ctx = SSL_get_SSL_CTX(ssl);
    if (set_keylog_file(ssl_ctx, global_settings->ssl_key_log_file))
      fprintf(stderr,"UNABLE TO USE KEYLOGGING\n");
    */
#else
    if (ssl->s3 && session->master_key_length > 0) {
      memcpy(client_random, ssl->s3->client_random, SSL3_RANDOM_SIZE);
      master_key_length = session->master_key_length;
      memcpy(master_key, session->master_key, master_key_length);
    }
    if(master_key_length > 0)
    {
      NSDL4_SSL(NULL, NULL, "write key to SSL_KEY_LOG file %s",global_settings->ssl_key_log_file);
      write_to_fd(global_settings->ssl_key_log_fd, client_random, master_key,master_key_length);
    }
#endif 
  }
}
