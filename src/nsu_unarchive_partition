#!/bin/bash
# shell unarchives range of partition.
#
#By Krishna Tayal

chk_disk_free() 
{
  REQ_SIZE=`du -bs $ARCHIVE | awk '{print $1}'`  #Tar file size in bytes
  REQ_SIZE=`expr $REQ_SIZE \* 20 / 1024`  #Required size = 20 * tar size in KB

  #DF_AVAIL=`df | awk '{if($NF == "/") print $(NF-2)}'`
  DF_AVAIL=`df -T $NS_WDIR | tail -1 | awk '{print $5}'` #Available disk in KB

  if [ "X$DF_AVAIL" = "X" ]; then
    echo "Could nor get free disk space"
    echo "Unable to unarchive Partition '$PARTITION'"
    exit 1
  elif [ $DF_AVAIL -le $REQ_SIZE ]; then
    echo "Free disk space $DF_AVAIL KB is less than $REQ_SIZE KB"
    echo "Unable to unarchive Partition '$PARTITION'"
    exit 1
  fi
}

update_summary_top() 
{
 #Get User:Group
 OWNER=`stat -c %U:%G $PARTITION_PATH/summary.top`
 #echo "OWNER=$OWNER"
 echo " Saving/Updating summary.top of partition '$PARTITION_PATH'"

 cat $PARTITION_PATH/summary.top | awk -F'|' '{
              for(i=1; i <NF; i++) {
                if(i == 14) {
                  if(match($i, "AR"))
                    printf "R|";
                  else if(match($i, "AW"))
                    printf "W|";
                } else {
                   printf $i"|";
                }
              }
              print $i
            }' >$PARTITION_PATH/summary.top.save

 chown $OWNER $PARTITION_PATH/summary.top.save
 mv $PARTITION_PATH/summary.top.save $PARTITION_PATH/summary.top
}

ISND=0

upload_database()
{

  rm $NS_WDIR/logs/TR$TR/$PARTITION/reports/csv/.*.offset 2>/dev/null
 
  echo "Uploading database of Partition '$PARTITION'"

  $NS_WDIR/bin/nsu_db_upload -t $TR -p $PARTITION 

  if [ $? != 0 ];then
    echo "Error in running command '$NS_WDIR/bin/nsu_db_upload -t $TR -p $PARTITION'" 
    return
  fi

  if [ $ISND != 0 ];then #if NET_DIGNOSTICS keyword enabled in scenario

  rm $NS_WDIR/logs/TR$TR/$PARTITION/nd/csv/.*.offset 2>/dev/null
  rm $NS_WDIR/logs/TR$TR/$PARTITION/nd/csv/*/.*.offset 2>/dev/null
  
    $NS_WDIR/bin/ndu_db_upload -t $TR -p $PARTITION
    if [ $? != 0 ];then
      echo "Error in running command '$NS_WDIR/bin/ndu_db_upload -t $TR -p $PARTITION'" 
      return
    fi
  fi
}

find_prev_unarchived_partition()
{
  index=`expr $PIDX - 1`
  PREV_UNARCHIVED_PARTITION=0
  while [ $index -ge 0 ]
  do
    TMP=${ALL_PARTITIONS[$index]}
    if [ ! -f $TR_PATH/$TMP/archive${TMP}.tar.gz ]; then
      PREV_UNARCHIVED_PARTITION=$TMP
      break
    fi 
    index=`expr $index - 1`
  done

  #if [ "X$PREV_UNARCHIVED_PARTITION" = "X0" ]; then
  #  echo "No unarchived partition found before partition $PARTITION, exiting.."
  #  exit 1
  #fi
}

find_next_unarchived_partition()
{
  index=`expr $PIDX + 1`
  NEXT_UNARCHIVED_PARTITION=0
  NUM_PARTITIONS=${#ALL_PARTITIONS[@]}

  while [ $index -lt $NUM_PARTITIONS ]
  do
    TMP=${ALL_PARTITIONS[$index]}
    if [ ! -f $TR_PATH/$TMP/archive${TMP}.tar.gz ]; then
      NEXT_UNARCHIVED_PARTITION=$TMP
      break
    fi 
    index=`expr $index + 1`
  done

  #if [ "X$NEXT_UNARCHIVED_PARTITION" = "X0" ]; then
  #  echo "No unarchived partition found after partition $PARTITION, exiting.."
  #  exit 1
  #fi
}

unarchive_partition()
{
  PARTITION_PATH="$TR_PATH/$PARTITION"
  ARCHIVE="$TR_PATH/$PARTITION/archive$PARTITION.tar.gz"

  #Get partition owner
  OWNER=`stat -c %U:%G $PARTITION_PATH`

  # Partition must exist
  if [ ! -d $PARTITION_PATH ];then
    echo "Partition '$PARTITION_PATH' does not exist."
    exit 1
  fi

  # Must be archived
  if [ ! -f $ARCHIVE ];then
    echo "Partition '$PARTITION_PATH' is not archived."
    return
  fi

  if [ $PREV_UNARCHIVED_PARTITION -gt 0 -a ! -f $TR_PATH/$PREV_UNARCHIVED_PARTITION/.partition_info.txt ]; then
    echo "File $TR_PATH/$PREV_UNARCHIVED_PARTITION/.partition_info.txt not found"
    exit 1
  fi

  if [ $NEXT_UNARCHIVED_PARTITION -gt 0 -a ! -f $TR_PATH/$NEXT_UNARCHIVED_PARTITION/.partition_info.txt ]; then
    echo "File $TR_PATH/$NEXT_UNARCHIVED_PARTITION/.partition_info.txt not found"
    exit 1
  fi

  #check if space available to unarchive partition
  chk_disk_free

  #No need to call it, because old summary.top will overwrite it when tar is exctracted 
  #Update summary.top
  #update_summary_top

  #Decompress partition
  cd $PARTITION_PATH
  echo "Unarchiving Partition '$PARTITION'"
  tar xzf $ARCHIVE 2>/dev/null
  if [ $? != 0 ];then
    echo "Unable to unarchive $ARCHIVE"
    exit 1
  fi

  #Remove tar
  rm -f $ARCHIVE

  if [ $PREV_UNARCHIVED_PARTITION -gt 0 ]; then
    #Update NextPartition in previous partition
    sed -i "s/^NextPartition=.*/NextPartition=$PARTITION/" $TR_PATH/$PREV_UNARCHIVED_PARTITION/.partition_info.txt
  else
    #Update first partition in .curPartition
    sed -i "s/^FirstPartitionIdx=.*/FirstPartitionIdx=$PARTITION/" $TR_PATH/.curPartition
  fi

  #Update PrevPartition in next partition 
  if [ $NEXT_UNARCHIVED_PARTITION -gt 0 ]; then
    sed -i "s/^PreviousPartition=.*/PreviousPartition=$PARTITION/" $TR_PATH/$NEXT_UNARCHIVED_PARTITION/.partition_info.txt
  else
    #Update cur partition in .curPartition
    sed -i "s/^CurPartitionIdx=.*/CurPartitionIdx=$PARTITION/" $TR_PATH/.curPartition
  fi

  #Correct and update entries in current partition
  sed -i "s/^PreviousPartition=.*/PreviousPartition=$PREV_UNARCHIVED_PARTITION/" $TR_PATH/$PARTITION/.partition_info.txt
  sed -i "s/^NextPartition=.*/NextPartition=$NEXT_UNARCHIVED_PARTITION/" $TR_PATH/$PARTITION/.partition_info.txt

  echo "	Established link successfully between partitions."

  #Upload data 
  if [ $UPLOAD_DB -eq 1 ]; then
    if [ -f $PARTITION_PATH/.db_exists ]; then
      echo "DB was not removed while archiving partition, hence not uploading again"
      rm -f $PARTITION_PATH/.db_exists
    else
      upload_database
    fi
  fi

  echo "        Partition $PARTITION unarchived successfully."
  echo "        Total size of $PARTITION after unarchive is `du -hs $PARTITION_PATH | awk '{print $1}'`"
}

#Unarchive Partition
unarchive_all_partitions() 
{
  PARTITION=$START_PARTITION
  while true
  do
    if [ "X$NEXT_UNARCHIVED_PARTITION" = "X" -o "X$PARTITION" = "X$NEXT_UNARCHIVED_PARTITION" ]; then
      find_next_unarchived_partition
    fi
    if [ "X$PREV_UNARCHIVED_PARTITION" = "X" ]; then
      find_prev_unarchived_partition
    else
      PREV_UNARCHIVED_PARTITION=${ALL_PARTITIONS[$PIDX - 1]}
    fi

    unarchive_partition

    PIDX=`expr $PIDX + 1`
    PARTITION=${ALL_PARTITIONS[$PIDX]}
    if [ "X$PARTITION" = "X" ]; then
      break
    elif [ "$PARTITION" -le "0" -o "$PARTITION" -gt "$END_PARTITION" ]; then
      break
    fi
  done
}

usage() 
{
  echo $* 
  echo "$0 -d <TR_PATH> & -p <Partition> | -s <Start Partition> -e <End Partition>"
  echo "Example:"
  echo "$0 -p 20140821115559 -d path "
  echo "OR"
  echo "$0 -s 20140821115559 -e 20140821116559 -d path"
  exit 1
}

S_FLAG=0
E_FLAG=0
P_FLAG=0
UPLOAD_DB=1

USER=`whoami`
if [ "X$USER" != "Xcavisson" ];then
    echo "You must be logged in as cavisson user to execute this command"
    exit -1
fi

while getopts t:s:e:p:dw:? c
do
  case $c in
        t) TR=$OPTARG;;
	s) echo $OPTARG | egrep "[^0-9]" >/dev/null 2>&1
           if [ $? == 0 ];then
              echo "Start Partition must be an integer value."
              exit 1
           fi
           START_PARTITION=$OPTARG
	   S_FLAG=1;;
	e) echo $OPTARG | egrep "[^0-9]" >/dev/null 2>&1
           if [ $? == 0 ];then
              echo "End Partition must be an integer value."
              exit 1
           fi
           END_PARTITION=$OPTARG
	   E_FLAG=1;;

	p) echo $OPTARG | egrep "[^0-9]" >/dev/null 2>&1
           if [ $? == 0 ];then
              echo "Partition must be an integer value."
              exit 1
           fi
           START_PARTITION=$OPTARG
           END_PARTITION=$OPTARG
	   P_FLAG=1;;
        d) UPLOAD_DB=0;;
        w) NS_WDIR=$OPTARG;;
	?) usage ;;
  esac
done

if [ "XX$NS_WDIR" == "XX" ];then
    echo "NS_WDIR is not exported."
    exit 1
fi

if [ -f $NS_WDIR/logs/TR$TR/sorted_scenario.conf ];then
  ISND=`grep ^NET_DIAGNOSTICS_SERVER $NS_WDIR/logs/TR$TR/sorted_scenario.conf | cut -d ' ' -f2`
  TOPOLOGY_NAME=`grep ^HIERARCHICAL_VIEW $NS_WDIR/logs/TR$TR/sorted_scenario.conf | cut -d ' ' -f3`
else
  ISND=`grep ^NET_DIAGNOSTICS_SERVER $NS_WDIR/logs/TR$TR/scenario | cut -d' ' -f2`
fi
if [ "X$ISND" == "X" -o "X$ISND" == "X0" ];then
  ISND=0
else
  ISND=1
fi

#Check for mandatory arguments
if [ "X$TR" = "X" ]; then
  usage "-t option is not provided"
elif [ $S_FLAG -ne $E_FLAG ]; then
  usage "One of -s and -e options is missing"
elif [ $P_FLAG -eq $S_FLAG -o $P_FLAG -eq $E_FLAG ]; then
  usage "Either -p option or -s/-e option can be used"
elif [ $P_FLAG -eq 0 -a $START_PARTITION -gt $END_PARTITION ]; then
  usage "Start Partition '$START_PARTITION' must be smaller than End Partition '$END_PARTITION'"
fi

TR_PATH="$NS_WDIR/logs/TR$TR"

ALL_PARTITIONS=( $(ls $TR_PATH | egrep "^[0-9]{14}$") )
PIDX=`echo ${ALL_PARTITIONS[@]} | awk -F"$START_PARTITION" '{print $1}' | wc -w`

unarchive_all_partitions
exit 0
