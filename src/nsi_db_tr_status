#!/bin/bash
#######################################################################################################
# Name   :nsi_db_tr_status
# Syntax : nsi_db_tr_status --testrun <value>
#
#   Author : Ankit Agarwal
#   Date :   13 July 2012
#   Purpose :This shell will check the status of DataBase,DataBase Tables,CSVFiles and testrun and give output in format 
#            DBStatus|DBTableStatus|CSVFileStatus|TRStatus
#
#   Author: Jitesh Sehgal
#   Modified Date: 13 May, 2016
# Example : nsi_db_tr_status --testrun 5919
#
#
#########################################################################################################

. $NS_WDIR/bin/nsi_db_utils
check_mandatory_args()
{
  if [ "X$NS_WDIR" = "X" ]; then
    usage "Error: NS_WDIR is not set."
  fi
  if [ "X$TRNUM" = "X" ]; then
    usage "Missing value of mandatory option --testrun."
  fi
}

usage()
{
  echo ""
  echo "$*"
  echo "USAGE:"
  echo "====="
  echo
  echo "$0 --testrun <TR Number>"
  echo 
  echo "Where"
  echo "  --testrun is test run number, which is mandatory argument."
  exit 1
}

#Show output of shell
show_op()
{
echo "DBStatus|DBTableStatus|CSVFileStatus|TRStatus"
echo "$DBSTATUS|$DBTABLESTATUS|$CSVSTATUS|$TRSTATUS"
}

#this function will set DBSTATUS(postgrsql) is running or notrunning
check_if_pg_running()
{
  OS_NAME=`nsi_get_linux_release_ex -d`
  if [ "$OS_NAME" = "Ubuntu" ]; then
    DBSTATUS=`isPgRunning`
    if [ $DBSTATUS -eq 0 ]; then
      DBSTATUS="Running"
    else
      DBSTATUS="Not Running"
    fi
  else
    /etc/init.d/postgresql status | grep -i running >/dev/null
    if [ $? -eq 0 ];then
      DBSTATUS="Running"
    fi
  fi

  if [ "X$DBSTATUS" = "X" -o "X$DBSTATUS" = "X " ]; then
    DBSTATUS="NotRunning"
    DBTABLESTATUS="NA_DB_is_Down"
    CSVSTATUS="NA_DB_is_Down"
    #output of shell
    show_op
    exit 0
  fi
}

#validate schema(columns) get from schema conf files and schema(columns) get from DB
validate_schema()
{
  #read line by line from tmp file
  #loop to get table names and column names(schema) of that table
  while read line
  do
    #Match 'TableName' word in line and get tablename
    echo "$line" | grep -i "^TableName" 1>/dev/null 2>/dev/null

    #check return status of previous command
    if [ $? -eq 0 ]; then
      #get table name from line
      TABLE_NAME_IN_FILE=`echo $line| awk -F':' '{print $2}' | sed 's/ *//g'`
      continue
    fi
    
    #Match 'Schema' word in line and get tablename
    echo "$line" | grep -i "^Schema" 1>/dev/null 2>/dev/null
    #check return status and check if table name is urlrecord then skip urlrecord table
    if [ $? -ne 0  -o "X$TABLE_NAME_IN_FILE" = "Xurlrecord" ]; then
      continue
    fi
     
    #if orl_present is 0 means orl monitors are present and check if table name is any oracle table then skip all oracle tables
    if [ $orl_present -eq 0 ]; then
      echo "$TABLE_NAME_IN_FILE" | grep -i "^orl" >/dev/null
      if [ $? -eq 0 ]; then
        continue
      fi
    fi
    
    #add testrun number in table names
    TABLE_NAME_IN_FILE="${TABLE_NAME_IN_FILE}_$TRNUM"
 
    #It will get schema and replace , to new line and make output like: table_name1,column1
    TABLE_SCHEMA_IN_FILE=`echo $line | awk -F':' '{print $2}' | tr ',' '\n' | grep -v "^$" | awk -v tbl="$TABLE_NAME_IN_FILE" '{printf "\n%s,%s", tbl,$1}'`

    #It will append output of previous command to SCHEMA_IN_FILE variable thus make output like: table_name1,column1
    #                                                                                            table_name1,column2
    SCHEMA_IN_FILE="${SCHEMA_IN_FILE} ${TABLE_SCHEMA_IN_FILE}"
  done<$TMP_FILE

  #After reading full file remove tmp file
  rm -f $TMP_FILE

  #ignore new line and sort and unique output of SCHEMA_IN_FILE
  SCHEMA_IN_FILE=`echo "$SCHEMA_IN_FILE" | sed 's/ //g' | grep -v "^$" | sort | uniq`

  #Ignore urlrecord table from output of SCHEMA_IN_DB 
  SCHEMA_IN_DB=`echo "$SCHEMA_IN_DB" | grep -v "^urlrecord"`

  #If DBTABLESTATUS is not present then return from this function
  if [ "X$DBTABLESTATUS" = "XNotPresent" ];then
    return
  fi

  #match columns of ND and NS schema conf files and colmuns in DB
  if [ "X$SCHEMA_IN_FILE" != "X$SCHEMA_IN_DB" ]; then
    DBTABLESTATUS="Partial"
  else
    DBTABLESTATUS="Present"
  fi
}

#Read and parse nd_db_csv.conf ns_db_csv.conf files and get csv and table names
read_csv_conf_file()
{
  #check if IS_ND_ENABLED is 0 then no need to parse nd_db_csv.conf file as this test is not ND enabled
  if [ "X$IS_ND_ENABLED" != "X0" ]; then
    CSV_CONF_FILE_PATH="$NS_WDIR/etc/dbconf/nd_db_csv.conf"
    #Check if nd_db_csv.conf is present
    if [ ! -f "$CSV_CONF_FILE_PATH" ]; then
      echo "Error: $CSV_CONF_FILE_PATH file is not present."
      exit 1
    else
      #Get table names and csv names from conf file
      ND_TABLE_NAMES=$(cat $CSV_CONF_FILE_PATH | egrep -v "^ *#|^ *$" | awk -F'|' -v TRNum="$TRNUM" '{if($4 != "") printf "%s_%s\n", $4, TRNum}')
      ND_CSV_NAMES=$(cat $CSV_CONF_FILE_PATH | egrep -v "^ *#|^ *$" | awk -F'|' '{if($1 != "") print $1}')
    fi
  fi

  #Parse ns_db_csv.conf file and get csv names and table names
  CSV_CONF_FILE_PATH="$NS_WDIR/etc/dbconf/ns_db_csv.conf"

  #Check if ns_db_csv.conf is present
  if [ ! -f "$CSV_CONF_FILE_PATH" ]; then
    echo "Error: $CSV_CONF_FILE_PATH file is not present."
    exit 1
  else
    NS_TABLE_NAMES=$(cat $CSV_CONF_FILE_PATH | egrep -v "^ *#|^ *$" | awk -F'|' -v orl_pres="$orl_present" -v TRNum="$TRNUM" '{if(($4 != "") && ((orl_pres) || (!orl_pres && ($2 != "2") && ($2 != "3")))) printf "%s_%s\n", $4, TRNum}')
    NS_CSV_NAMES=$(cat $CSV_CONF_FILE_PATH | egrep -v "^ *#|^ *$" | awk -F'|' -v orl_pres="$orl_present" '{if(($1 != "") && ((orl_pres) || (!orl_pres && ($2 != "2") && ($2 != "3")))) print $1}')
  fi

  #Get total tables in ND and NS conf files and some other 6 tables
  TABLE_NAMES_IN_CONF_FILE="UserProfile_$TRNUM ErrorCodes_$TRNUM ActualServerTable_$TRNUM RecordedServerTable_$TRNUM SessionProfile_$TRNUM LogPhaseTable_$TRNUM"
  TABLE_NAMES_IN_CONF_FILE="$TABLE_NAMES_IN_CONF_FILE $ND_TABLE_NAMES $NS_TABLE_NAMES" 

  #Make array of total tables and total csv files in ND and NS conf files and 6 other csv files 
  #If tables and csv are in capital letters make them small letters as in DB tables in small letters
  TABLE_ARR=(`echo $TABLE_NAMES_IN_CONF_FILE | tr '[A-Z]' '[a-z]'`)
  CSV_ARR=(`echo upf.csv ect.csv hat.csv hrt.csv spf.csv log_phase_table.csv $ND_CSV_NAMES $NS_CSV_NAMES`)

  #Get count of total tables in both ND and NS conf files
  TOTAL_TABLE_NAMES_IN_CONF_FILE="${#TABLE_ARR[@]}"

  TABLE_NAMES_IN_CONF_FILE=`echo "$TABLE_NAMES_IN_CONF_FILE" | tr ' ' '\n' | grep -v "^$" | sort | uniq | tr '[A-Z]' '[a-z]'`
}

#Read ns_db_schema.conf and nd_db_schema.conf schema configuration files 
read_schema_conf_file()
{
  #Check if ns_db_schema.conf is present
  NS_SCHEMA_CONF_FILE_PATH="$NS_WDIR/etc/dbconf/ns_db_schema.conf"
  if [ ! -f "$NS_SCHEMA_CONF_FILE_PATH" ]; then
    echo "Error: $NS_SCHEMA_CONF_FILE_PATH file is not present."
    exit 1
  fi
  #Read NS schema file and ignore blank and commented lines and redirect it to tmp file 
  cat $NS_SCHEMA_CONF_FILE_PATH | grep -v "^#" | grep -v "^ *$" | sed 's/--.*$//' | tr '\n' ' ' | tr ';' '\n' | tr '\t' ' '|sed 's/^ *//' | egrep -i -v '^PrimaryKey|^Index' | sed 's/  */ /g' | tr '[A-Z]' '[a-z]' > $TMP_FILE


  #Check if IS_ND_ENABLED is 0 then no need to parse conf file as this is non ND test
  if [ "X$IS_ND_ENABLED" != "X0" ]; then 
    #Check if nd_db_schema.conf is present
    ND_SCHEMA_CONF_FILE_PATH="$NS_WDIR/etc/dbconf/nd_db_schema.conf"
    if [ ! -f "$ND_SCHEMA_CONF_FILE_PATH" ]; then
      echo "Error: $ND_SCHEMA_CONF_FILE_PATH file is not present."
      exit 1
    fi
    #Read ND schema file and ignore blank and commented lines and append it to tmp file
    cat $ND_SCHEMA_CONF_FILE_PATH | grep -v "^#" | grep -v "^ *$" | sed 's/--.*$//' | tr '\n' ' ' | tr ';' '\n' | tr '\t' ' '|sed 's/^ *//' | egrep -i -v '^PrimaryKey|^Index' | sed 's/  */ /g' | tr '[A-Z]' '[a-z]' >> $TMP_FILE
  
  fi
}


#validate count of csv fields and count of columns of respective table from DB 
validate_csv()
{
  #Get column count from conf file, output is like: table name1,value
  #                                                 table name2,value
  COL_COUNT_IN_CONF_FILE=`echo "$SCHEMA_IN_FILE" | awk -F ',' '{print $1}' | sort | uniq -c| awk '{printf "%s,%s\n", $2, $1}' | sort`
  

  #loop upto total tables in conf file to get fields from csv 
  for((i=0; i<$TOTAL_TABLE_NAMES_IN_CONF_FILE; i++));
  do
    #Check csv names from all paths for ND(Static or Dynamic csv's) or NS(Static or Dynamic csv's) and if csv file exist then get first line of    #csv file and get total no of fields in that line 
    CSV_LINE=`cat $NS_WDIR/logs/TR$TRNUM/2*/nd/csv/*/${CSV_ARR[i]} $NS_WDIR/logs/TR$TRNUM/2*/nd/csv/${CSV_ARR[i]} $NS_WDIR/logs/TR$TRNUM/nd/csv/${CSV_ARR[i]} $NS_WDIR/logs/TR$TRNUM/nd/csv/*/${CSV_ARR[i]} $NS_WDIR/logs/TR$TRNUM/2*/reports/csv/${CSV_ARR[i]} $NS_WDIR/logs/TR$TRNUM/common_files/reports/csv/${CSV_ARR[i]} 2>/dev/null | head -1 |awk -F',' '{print NF}'`

    #if CSV_LINE is empty means csv file is empty in that case from TABLE_ARR get second value from that line
    #like if metadata csv file is empty, now from COL_COUNT_IN_CONF_FILE search metadata_TR,value
    #Now in csv line value is stored
    if [ "X$CSV_LINE" = "X" ]; then
      CSV_LINE=`echo "$COL_COUNT_IN_CONF_FILE" | grep  "^${TABLE_ARR[i]}" | awk -F',' '{print $2}'`
    fi

    #In this output like this: table name1,value
    #                          table name2,value
    COL_COUNT_IN_CSV="$COL_COUNT_IN_CSV ${TABLE_ARR[i]},$CSV_LINE"
  done

  #In COL_COUNT_IN_CSV replace space to newline and ignore newline and ignore urlrecord table and sort and uniq list
  COL_COUNT_IN_CSV=`echo "$COL_COUNT_IN_CSV" | tr ' ' '\n' | grep -v "^ *$" | grep -v "urlrecord" | sort | uniq`

  #Match columns count in conf file and count in csv
  if [ "X$COL_COUNT_IN_CONF_FILE" = "X$COL_COUNT_IN_CSV" ]; then
    CSVSTATUS="Present"
  else
    CSVSTATUS="Partial"
  fi
}

#Get all tables and their column names of testrun from database
get_data_from_DB()
{
  #Make connection with DB, Run query, get tables and columns of that table
  #this query will return output like that:  table_name1, column1
  #                                          table_name1, column2
  SCHEMA_IN_DB=$(psql --user=cavisson -d test -t --no-align   --field-separator ',' --pset footer -c "Select table_name,column_name from Information_Schema.columns where Table_Name ilike '%\_$TRNUM';")

  #sort and make unique the output get from query
  SCHEMA_IN_DB=`echo "$SCHEMA_IN_DB" | sort | uniq`

  #get table names from table_name, column1
  #                     table_name, column2  where we get (table_name) and do sort and unique command
  TABLE_NAMES_IN_DB=`echo "$SCHEMA_IN_DB" | awk -F ',' '{print $1}' | sort | uniq`
}


#match table names in conf files and tables get from DB
validate_table_names()
{
  if [ "X$TABLE_NAMES_IN_CONF_FILE" != "X$TABLE_NAMES_IN_DB" ]; then
    DBTABLESTATUS="NotPresent"
  else
    DBTABLESTATUS="Present"
  fi
}

######################################################################

TRSTATUS=""
DBSTATUS=""
DBTABLESTATUS=""
CSVSTATUS=""
orl_present=0

TMP_FILE="/tmp/tmp_schema.$$"

#Parsing the arguments
#init will return 2 if test is running and 1 if not
init $*
IS_TR_RUNNING=$?
check_mandatory_args

if [ $IS_TR_RUNNING -eq 2 ];then
  TRSTATUS="Running"
else
  TRSTATUS="NotRunning"
fi

#Check if test in ND enabled
IS_ND_ENABLED=`awk '/^NET_DIAGNOSTICS_SERVER/ {print $2}' $NS_WDIR/logs/TR$TRNUM/sorted_scenario.conf`

#check if ND mode is not equal to 1,2 then we set IS_ND_ENABLED flag to 0 means, non ND test
if [ "X$IS_ND_ENABLED" != "X1" -a "X$IS_ND_ENABLED" != "X2" ]; then
   IS_ND_ENABLED=0
fi

#check postgresql is running or not
check_if_pg_running

#Check if orl monitors are present
if [ -f $NS_WDIR/logs/TR$TRNUM/common_files/.oracle_sql_report ]; then
  orl_present=1
fi

#Get all table_names and columns of that table from DB of given testrun
get_data_from_DB

#Read and parse ND and NS csv configuration files and get total csv names and total table names from conf files
read_csv_conf_file

#validate total tables in conf files and total tables in DB,if they mismatch then set DBTABLESTATUS to notpresent else present 
validate_table_names

#Read and parse NS and ND schema conf files
read_schema_conf_file

#validate columns(schema) of ND and NS schema conf files and columns get from DB, if some mismatch then set DBTABLESTATUS to 'partial' otherwise set 'present'
validate_schema

#match csv fields count with columns count get from DB, if mismatch then set CSVSTATUS to Notpresent else present
validate_csv

#output of shell including headers
show_op
exit 0
