#!/bin/bash
#---------------------------------------------------------------------------------
# Name     : get_touched_file
#
# Purpose  : It is a utility, whoes purpose is to list down all the files
#      modified within last 7 days, so that no file is left over from
#      commit. Its required is raised by Achint Agarwal
#
# Author  : Tanmay Prakash
#
# Date    : 30th Oct, 2016
#
#        Copyright Cavisson Systems Inc. 2016
#---------------------------------------------------------------------------------

ALL=0;
TIME=7
inside_touch_in_dir=0;
RED=`tput setaf 1`
GREEN=`tput setaf 2`
BLUE=`tput setaf 4`
BOLD=`tput bold`
RESET=`tput sgr0`

usage()
{
    echo "$BOLD""$RED""Usage :"
    echo "get_touched_file -d <Directory name relative from src/> -a <search all sub-directories recursively> -t <time in no. of days>" "$RESET"
    echo ""
    echo "$BOLD""$BLUE""Description : get_touched_file" "$RESET"
    echo "$BLUE""This utiliy helps in listing all the recently modified file in the local system,"
    echo "and validate its status from repository, its motive is to check all modified before cvs commit" "$RESET"
}


check_args()
{
  if [ $OPTIND -eq 1 ]; then
    echo " No command line argument is given."
    while true; do
        read -e -p "$RED Do you wish to continue to search Directory Recursively? (y/n) $GREEN" ans
        echo $RESET
        case $ans in
          [yY]* ) ALL=1 
		 touched_in_dir
          break;;
          [nN]* ) usage 
          exit;;
        esac
    done
  fi
    if [[ ( "X$DIRNAME" != "X" ) && ( "X$ALL" == "X1" ) ]]; then
    echo "Error: You cannot apply both argument simultaneously"
    usage
  fi
}


touched_in_dir()
{ 
  inside_touch_in_dir=1
  echo -n "Please wait"
  if [ "X$ALL" == "X1" ]; then
   #find . -type f -mtime 0 -print | grep "/" >/tmp/tmp_touch_file &
   find . -type f -mtime -${TIME} -print | grep "/" >/tmp/tmp_touch_file &
  elif [ -d $PWD/$DIRNAME ];then
   # ask achint sir how handle this
   find $PWD/$DIRNAME -type f -mtime -${TIME} -print | grep "/" >/tmp/tmp_touch_file &
  fi
  command_pid=`echo $!`
  while [ -d /proc/$command_pid ]; do
    #echo -n "."
    sleep 1
  done
  echo -en "\rSearch Completed !"
  echo ""
  fetch_only_cvs_file
}


fetch_only_cvs_file()
{
  file_list=( $( awk -F'/' '{print $NF}' /tmp/tmp_touch_file ) )
  #file_list=( $(awk -F'/' '{ st = index($0,":");print"" substr($0,st+1)}' /tmp/tmp_touch_file ) )
  echo "" |  awk 'BEGIN{ printf "%-70s |%-20s|\n", "FILE", "STATUS"}; var="+"{printf "%-70s %-20s %s\n",var1,var,var;}' |sed '2s/ /-/g '
  
  for (( i=0; i<${#file_list[@]}; i++ ))
  do
    if [ "X$ALL" == "X1" ];then
      check_file_status=`cvs -n update ${file_list[$i]} 2>/dev/null | grep '^M'`
    else
      check_file_status=`cvs -n update $DIRNAME/${file_list[$i]} 2>/dev/null | grep '^M'`
    fi
    if [ "X$check_file_status" != "X" ]; then
      awk -v file="${file_list[$i]}" -v stat="$BOLD""$RED""Modified""$RESET" 'BEGIN {printf "%-70s |%-20s            |\n", file, stat}'
   # else
      #awk -v file="${file_list[$i]}" -v stat="$BOLD""Locally Modified""$RESET" 'BEGIN {printf "%-70s |%-20s    |\n", file, stat}'
      #awk -v file="${file_list[$i]}" -v stat="$BOLD""Locally Modified""$RESET" 'BEGIN {printf "%60s      \n", stat}'
    fi
  done
}


handle_signals()
{
  #echo ""
  echo $RESET
  echo -n "$BOLD" "Encounter a $RED Interupt Signal, please wait $RESET"
  for i in `seq 1 5`; do
    sleep 0.3
    echo -n "."
    if [[ -f /tmp/tmp_touch_file ]]; then
      rm /tmp/tmp_touch_file 2>/dev/null
    fi
    kill -9 $command_pid 2>/dev/null
  done
  echo $RESET
  #echo ""
  exit 1
}


remove_tmp_file()
{
  if [[ -f /tmp/tmp_touch_file ]]; then
    rm /tmp/tmp_touch_file 2>/dev/null
  fi
  if [ "X$command_pid" != "X" ];then
    kill -9 $command_pid 2>/dev/null
  fi
  echo $RESET
}


while getopts d:t:ah? c
do
  case $c in
    d) DIRNAME=$OPTARG;;
    a) ALL=1;;
    t) TIME=$OPTARG;;
    h)
      usage;;
  esac
done

trap handle_signals INT

check_args

if [ "X$DIRNAME" != "X" ]; then
  # This regex is a check for absolute path - source internet
 # if [[ "$DIRNAME" = /* ]]; then
   if [[ ( -d $PWD/$DIRNAME )  && ( "X$inside_touch_in_dir" == "X0" ) ]]; then
     touched_in_dir
  else
     echo "Error is accessing $PWD/$DIRNAME ; Give directory path relative to cavisson/src/*"
  fi
fi

if [[ ( "X$ALL" == "X1" ) &&  ( "X$inside_touch_in_dir" == "X0" ) ]]; then
  touched_in_dir
fi

remove_tmp_file
