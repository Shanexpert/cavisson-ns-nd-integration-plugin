##############################################################################################
# Purpose : This shell will take care of providing process. Specilly for health monitor
#           If due to any reason health monitor killed then this shell will start health monitor again.
#
# Design  : This shell will take pid from parent and check this pid is running for a given interval
#           If pid is not running then it will satrt health monitor and update own pid variable and
#           again do monitor new pid. 
#
##############################################################################################

CHECK_HEALTH_MONITOR_LOGFILE="$NS_WDIR/system_health_monitor/logs/nsu_check_health_monitor.log"
PIDFILE="$NS_WDIR/system_health_monitor/bin/nsu_system_health_check.pid"

#Check file for lower build than 4.1.12.1
CHECK_FILE="$NS_WDIR/bin/nsi_migrate_cshm_conf"

#Binary of cshm which is to be monitored
CSHM_BINARY="$NS_WDIR/system_health_monitor/bin/nsu_system_health_check"

write_in_chk_health_monitor_logfile()
{
  STR=$1
  WRITE_FLAG=0

  if [ ! -f ${CHECK_HEALTH_MONITOR_LOGFILE} ]; then
    touch ${CHECK_HEALTH_MONITOR_LOGFILE}
    echo "`date +'%m/%d|%r'`|Chk mon log file (${CHECK_HEALTH_MONITOR_LOGFILE}) does not exists. Created chk mon log file ${CHECK_HEALTH_MONITOR_LOGFILE}"  >> $CHECK_HEALTH_MONITOR_LOGFILE
  fi

  #find file size
  #if size > CHECK_HEALTH_MONITOR_LOGFILE then rollover
  #else append with date and time
  if [ `ls -l $CHECK_HEALTH_MONITOR_LOGFILE | awk -F" " '{print $5}'` -gt $CHK_HEALTH_MONITOR_LOG_SIZE ]; then
    WRITE_FLAG=1
  fi

  if [ $WRITE_FLAG -eq 1 ]; then 
    #rollover
    mv ${CHECK_HEALTH_MONITOR_LOGFILE} ${CHECK_HEALTH_MONITOR_LOGFILE}.prev
    #touch ${LOGFILE}    
    echo "`date +'%m/%d|%r'`|$STR" >> $CHECK_HEALTH_MONITOR_LOGFILE
  else
    echo "`date +'%m/%d|%r'`|$STR" >> $CHECK_HEALTH_MONITOR_LOGFILE
  fi
}

start_health_monitor()
{
  write_in_chk_health_monitor_logfile "Health Monitor with pid $PID is not running. Hence Starting Health Monitor..." 
  write_in_chk_health_monitor_logfile "Starting Health Monitor..." 
  nohup $NS_WDIR/system_health_monitor/bin/nsu_system_health_check & >/dev/null 2>&1
  if [ $? == 0 ];then
    echo $! >$PIDFILE
    PID=`cat $PIDFILE`
  fi
}

check_health_monitor()
{
  while true
  do
    if [ -f "$CHECK_FILE" ];then   #checking if build is 4.1.12.1 or newer
      PIDS=`ps -ef | grep -w "${CSHM_BINARY}" | grep -vw "grep" | grep -vw "vi" | wc -l` #checking no. of pids of cshm
      if [ ${PIDS} -gt 1 ];then
        CSHM_PID=`ps -ef | grep -w "${CSHM_BINARY}" | grep -vw "grep" | grep -vw "vi" | grep -vw "${PID}" |  awk '{print $2}'`   #gettting all the pids
        write_in_chk_health_monitor_logfile "${PIDS} system health monitor running. Killing all of them."
        kill -9 ${CSHM_PID}   #killing all other cshm
      fi
      is_cshm_running=`$PS_CMD_FOR_DATA -o 'cmd' "${PID}" | grep -w "${CSHM_BINARY}" | wc -l`
      if [ ${is_cshm_running} == 0 ];then  #if health monitor is not running
        start_health_monitor
      else
        write_in_chk_health_monitor_logfile "Health Monitor is running with pid $PID."
      fi    
    else 
      write_in_chk_health_monitor_logfile "Exited due to lower build than 4.1.12.1."
      exit
    fi
    sleep $INTERVAL_SECS    
  done
}

###################### FUNCTION CALLING #####################################

while getopts p:i:s:? arg
do
  case $arg in
    p) PID="$OPTARG" ;;
    i) INTERVAL_SECS="$OPTARG" ;;       #INTERVAL_SECS in secs
    s) CHK_HEALTH_MONITOR_LOG_SIZE="$OPTARG" ;;    # check lps log max size
    ?) usage ;;
  esac
done

write_in_chk_health_monitor_logfile "HEALTH_MONITOR_PID = $PID, INTERVAL_SECS = $INTERVAL_SECS, CHK_HEALTH_MONITOR_LOG_SIZE = $CHK_HEALTH_MONITOR_LOG_SIZE"

set_ps_cmd()
{
  OS_NAME=`uname`
  if [ "X$OS_NAME" == "XSunOS" ]; then
    PS_CMD_FOR_DATA="/usr/bin/ps"
    if [ ! -f /usr/xpg4/bin/grep ];then
      echo "Error: grep command not found on path /usr/xpg4/bin/grep. Hence extended regular expression may not be supported."
      PS_GREP_CMD="/usr/bin/egrep -e"  #Search for a pattern_list(full regular expression that
   else
     PS_GREP_CMD="/usr/xpg4/bin/grep -E"
   fi
  else #Linux,AIX
    PS_CMD_FOR_DATA="ps"
    PS_GREP_CMD="grep -E"
  fi
}

set_ps_cmd
check_health_monitor 

exit 0
